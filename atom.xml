<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gujinli.github.io</id>
    <title>瑾离不是锦鲤的小窝</title>
    <updated>2021-12-26T04:12:29.181Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gujinli.github.io"/>
    <link rel="self" href="https://gujinli.github.io/atom.xml"/>
    <subtitle>ACM打铁/异地恋中——</subtitle>
    <logo>https://gujinli.github.io/images/avatar.png</logo>
    <icon>https://gujinli.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 瑾离不是锦鲤的小窝</rights>
    <entry>
        <title type="html"><![CDATA[codechef LTIME103B 赛后题解]]></title>
        <id>https://gujinli.github.io/post/codechef-ltime103b-sai-hou-ti-jie/</id>
        <link href="https://gujinli.github.io/post/codechef-ltime103b-sai-hou-ti-jie/">
        </link>
        <updated>2021-12-26T04:11:12.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.codechef.com/LTIME103B">比赛链接</a></p>
<h1 id="a-optimal-sorting">A. <a href="https://www.codechef.com/LTIME103B/problems/OPTSORT">Optimal Sorting</a><img src="https://www.codechef.com/sites/all/modules/codechef_tags/images/solved.png?v=1" alt="100/100" loading="lazy"></h1>
<blockquote>
<p>选择一段连续区间sort的代价是这段区间的最大值-最小值。求把整个数列sort的最小代价</p>
</blockquote>
<p>一整段区间分开sort更优 当且仅当 后面所有数的最小值 &gt; 当前最大值。即产生了一段<strong>空隙</strong></p>
<p>因为当前最大值如果大于后面所有数的最小值的话，必然要合并在一起sort。</p>
<p>维护后缀最小值从前向后枚举即可。复杂度 O(n)</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define vi vector&lt;int&gt;
#define pi pair&lt;int, int&gt;
#define fr(a) freopen(a, &quot;r&quot;, stdin)
#define fo(a) freopen(a, &quot;w&quot;, stdout);
#define mod 998244353
template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;}
template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;}
ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;}
using namespace std;
const int maxn = 200005;
/**/
int t, n, a[maxn], mi[maxn];
/**/
int main()
{
	// fr(&quot;test.in&quot;);
	ios::sync_with_stdio(0);cin.tie(0);
	cin &gt;&gt; t;
	while(t--) {
		cin &gt;&gt; n;
		for(int i = 1; i &lt;= n; i++) {
			cin &gt;&gt; a[i];
		}
		mi[n] = a[n];
		for(int i = n - 1; i &gt;= 1; i--) {
			mi[i] = min(mi[i + 1], a[i]);
		}
		int ans = 0, maxnum = 0, minnum = 0x3f3f3f3f;
		mi[n + 1] = INT_MAX;
		for(int i = 1; i &lt;= n; i++) {
			maxnum = max(maxnum, a[i]);
			minnum = min(minnum, a[i]);
			if(mi[i + 1] &gt; maxnum) {
				ans += maxnum - minnum;
				maxnum = 0;
				minnum = 0x3f3f3f3f;
			}
		}
		cout &lt;&lt; ans &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<h1 id="bsleep-technique">B.<a href="https://www.codechef.com/LTIME103B/problems/SLEEPTECH">Sleep Technique</a></h1>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[codechef INFI21B 赛后题解]]></title>
        <id>https://gujinli.github.io/post/codechef-infi21b-sai-hou-ti-jie/</id>
        <link href="https://gujinli.github.io/post/codechef-infi21b-sai-hou-ti-jie/">
        </link>
        <updated>2021-12-26T04:10:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="比赛链接"><a href="https://www.codechef.com/INFI21B">比赛链接</a></h1>
<h1 id="b-dalgona-treat">B. Dalgona Treat</h1>
<p><strong>题意：</strong> 求n个平方数相加得到一个完全平方数，数的种类不能超过10</p>
<p><strong>Solution：</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>=</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><msup><mo>)</mo><mn>2</mn></msup><mo>∗</mo><mn>1</mn><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>∗</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">n^2=(n-2)^2*1+2^2*(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>小于3的情况特判直接输出。注意<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">n=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>的时候，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，同样特判处理</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
int t;
int n;
int main()
{
	cin &gt;&gt; t;
	while(t--)
	{
		cin &gt;&gt; n;
		if(n == 1) puts(&quot;1\n1 1&quot;);
		else if(n == 2) puts(&quot;2\n3 1\n4 1&quot;);
		else if(n == 4) puts(&quot;1\n1 4&quot;);
		else
		{
			printf(&quot;2\n2 %d\n&quot;, n - 1);
			printf(&quot;%d 1\n&quot;, n - 2);
		}
	}
	return 0;
}
</code></pre>
<h1 id="c-tug-of-war">C. Tug of War</h1>
<p><strong>题意：</strong> A队有n人，B队有m人，给定了每个人的能力值ai和bi。A队按照(a1...n)的顺序出场，获胜的人留在场上，输了的人离场，平局都立场。求B队能否获胜，如果能的话，输出字典序最小的排列。</p>
<p><strong>Solution：</strong> 将B队降序排列。令p1表示A当前的人，p2表示B当前的人。用双指针找出B获胜需要的人，将剩余的人升序输出，获胜需要的人降序输出即可。</p>
<p><a href="https://discuss.codechef.com/t/tow-editorial/97247">证明见官方题解：</a></p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define ll long long
// #define int ll
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define vi vector&lt;int&gt;
#define pi pair&lt;int, int&gt;
#define vpii vector&lt;pi&gt;
#define il inline
#define ri register
#define all(a) a.begin(), a.end()
#define fr(a) freopen(a, &quot;r&quot;, stdin)
#define fo(a) freopen(a, &quot;w&quot;, stdout);
#define mod 998244353
template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;}
template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;}
ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;}
using namespace std;
const int maxn = 1000005;
/**/
int n, m, a[maxn], b[maxn];
/**/
il bool cmp(int x, int y) { return x &gt; y;}
il void solve() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
	for(int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;b[i]);
	sort(b + 1, b + 1 + m, cmp);
	int p1 = 1, p2 = 1, err = 0;
	while(p1 &lt;= n &amp;&amp; p2 &lt;= m) {
		if(a[p1] &gt; b[p2]) {
			err = 1;
			break;
		}
		else if(a[p1] &lt; b[p2]) { ++p1;
		else  ++p1, ++p2;
	}
	if(p2 &gt; m || err) {printf(&quot;NO\n&quot;); return;}
	printf(&quot;YES\n&quot;);
	for(int i = m; i &gt; p2; i--) cout &lt;&lt; b[i] &lt;&lt; ' ';
	for(int i = 1; i &lt;= p2; i++) cout &lt;&lt; b[i] &lt;&lt; ' ';
	puts(&quot;&quot;);
}
signed main()
{
	int T;
	cin &gt;&gt; T;
	while(T--) {
		solve();
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF 1591 div2 赛后题解]]></title>
        <id>https://gujinli.github.io/post/cf-1591-div2/</id>
        <link href="https://gujinli.github.io/post/cf-1591-div2/">
        </link>
        <updated>2021-12-26T04:10:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="d-yet-another-sorting-problem"><a href="https://codeforces.com/contest/1591/problem/D"> D - Yet Another Sorting Problem</a></h1>
<blockquote>
<p>一段长度为n的序列。每次可以选择一个三元组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i, j, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，然后将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_i, a_j,a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 三个数环形交换。即：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>k</mi></msub><mo>=</mo><msub><mi>a</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_j=a_i,a_k=a_j,a_i=a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>判断是否通过这样的操作（次数不限）使得序列有序</p>
</blockquote>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>k</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(a_i,a_j,a_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>三个数两两不相等时，我们发现，无论执行多少次这样的操作，逆序数只会改变0或2。</p>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>k</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(a_i,a_j,a_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>存在两个数相等时，逆序数可以改变1（也可以改变2）。</p>
<p>因此我们这样判断：如果逆序数%2==0，说明可以使逆序数变为0，即单调非降。</p>
<p>特别的，如果存在两个数相等，那么奇偶性就可以任意改变，故也可以使序列有序。</p>
<p>其余情况为NO。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(); while(c&gt;'9'||c&lt;'0') c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar(); }
const int N=5e5+5;
int n,c[N],rk[N], t;
int ans;
struct node
{
	int id,w;
	bool operator &lt; (const node &amp;b) const
	{
		return w==b.w?id&lt;b.id:w&lt;b.w;
	}
}a[N];
inline void insert(int x,int w)
{
	for(;x&lt;=n;x+=x&amp;-x) c[x]+=w;
}
inline int query(int x)
{
	int sum=0;
	for(;x;x-=x&amp;-x) sum+=c[x];
	return sum;
}
signed main()
{
	read(t);
	while(t--)
	{
		ans = 0;
		read(n);
		for(int i=1;i&lt;=n;i++) read(a[i].w),a[i].id=i;
		sort(a+1,a+1+n);
		bool flag = 0;
		for(int i = 2; i &lt;= n; i++)
		{
			if(a[i].w == a[i - 1].w) {flag = 1; break;}
		}
		if(flag) {puts(&quot;YES&quot;); continue;}
		for(int i=1;i&lt;=n;i++) rk[a[i].id]=i;
		for(int i=1;i&lt;=n;i++)
		{
			insert(rk[i],1);
			ans += i - query(rk[i]);
		}
		if(ans &amp; 1) puts(&quot;NO&quot;);
		else puts(&quot;YES&quot;);
		for(int i = 0; i &lt;= n; i++) c[i] = rk[i] = 0;
	}
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF 1620 div2 赛后题解]]></title>
        <id>https://gujinli.github.io/post/cf-1620-div2-sai-hou-ti-jie/</id>
        <link href="https://gujinli.github.io/post/cf-1620-div2-sai-hou-ti-jie/">
        </link>
        <updated>2021-12-26T04:09:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="d-exact-change"><a href="https://codeforces.com/contest/1620/problem/D">D - Exact Change</a></h1>
<p><strong>题意：</strong> n个价值为ai的物品。有1、2、3三种硬币，能表示出每个ai的价格最少需要多少枚硬币</p>
<p><strong>Solution：</strong> 首先1和2的个数都不可能超过3个，因为3个的话显然用面额3表示价格更大。因此枚举使用的1和2的数量，再判断3的数量即可。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
/**/
const int N = 105;
int t, n, a[N], ans;
/**/
int main()
{
    read(t);
    while(t--)
    {
        read(n);
        for(int i = 1; i &lt;= n; i++) read(a[i]);
        ans = 0x7f7f7f7f;
        for(int one = 0; one &lt;= 2; one++)
        {
            for(int two = 0; two &lt;= 2; two++)
            {
                int three = 0;
                for(int i = 1; i &lt;= n; i++)
                {
                    int minnum = 0x7f7f7f7f;
                    for(int use1 = 0; use1 &lt;= one; use1++)
                    {
                        for(int use2 = 0; use2 &lt;= two; use2++)
                        {
                            int res = a[i] - use1 - use2 * 2;
                            if(res &gt;= 0 &amp;&amp; res % 3 == 0)
                            {
                                minnum = min(minnum, res / 3);
                            }
                        }
                    }
                    three = max(three, minnum);
                }
                ans = min(ans, three + one + two);
            }
        }
        cout &lt;&lt; ans &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>
<h1 id="e-replace-the-numbers"><a href="https://codeforces.com/contest/1620/problem/E">E - Replace the Numbers</a></h1>
<p><strong>题意：</strong> 现在有q次操作，</p>
<ul>
<li>&quot;1 x&quot; — 在序列末尾添加一个x</li>
<li>&quot;2 x y&quot; — 将序列中所有的x替换成y</li>
</ul>
<p>输出这q次操作执行后的序列</p>
<p><strong>Solution：</strong> 并查集瞎搞。注意x==y的时候特判continue掉就好了。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
/**/
const int N = 5e5 + 5;
int t, opt, x, y, n, fa[N], rec[N], a[N];
/**/
inline int find(int x){return x == fa[x] ? x : fa[x] = find(fa[x]);}
int main()
{
	read(t);
	while(t--)
	{
		read(opt);
		if(opt == 1)
		{
			read(x);
			++n;
			if(rec[x]) fa[n] = fa[rec[x]];
			else fa[n] = n, rec[x] = n, a[n] = x;
		}
		else
		{
			read(x); read(y);
			if(!rec[x] || x == y) continue;
			if(rec[y]) fa[find(rec[x])] = rec[y], rec[x] = 0;
			else
			{
				int f2 = find(rec[x]);
				rec[y] = f2;
				a[f2] = y;
				rec[x] = 0;
			}
		}
	}
	for(int i = 1; i &lt;= n; i++)
	{
		cout &lt;&lt; a[find(i)] &lt;&lt; ' ';
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ABC 232 赛后题解]]></title>
        <id>https://gujinli.github.io/post/abc-232-sai-hou-ti-jie/</id>
        <link href="https://gujinli.github.io/post/abc-232-sai-hou-ti-jie/">
        </link>
        <updated>2021-12-25T08:30:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="e-rook-path">E - Rook Path</h1>
<p><strong>题意：</strong> 一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n*m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>的棋盘。初始点在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x1,y1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ， 求通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次移动后到达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x2,y2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>的方案数。</p>
<p>注：每次移动可以 移至当前列/当前行的任意一点。（不能站着不动）</p>
<p><strong>Solution：</strong></p>
<p>首先可以得出简单dp方程：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mn>2</mn></mrow><mrow><mi>j</mi><mn>2</mn><mi mathvariant="normal">≠</mi><mi>j</mi></mrow></munderover><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mn>2</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mn>2</mn></mrow><mrow><mi>i</mi><mn>2</mn><mi mathvariant="normal">≠</mi><mi>i</mi></mrow></munderover><msub><mi>f</mi><mrow><mi>i</mi><mn>2</mn><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k} = f_{i,j,k}=\sum_{j2}^{j2\ne j}f_{i,j2,k-1} + \sum_{i2}^{i2\ne i}f_{i2,j,k-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2969980000000003em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8832210000000005em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.347113em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mrel mtight"><span class="mrel mtight"><span class="mord mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="rlap mtight"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel mtight"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel mtight">=</span></span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.16089em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8832210000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.347113em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">2</span><span class="mrel mtight"><span class="mrel mtight"><span class="mord mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="rlap mtight"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel mtight"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel mtight">=</span></span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>简单手模之后我们可以发现一个显然的规律就是，对于一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>只会有四个不同的取值，分别对应：</p>
<blockquote>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>=</mo><mo>(</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f_{0,0} =(x1, y1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>=</mo><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo>)</mo><mspace width="1em"/><mi>x</mi><mi mathvariant="normal">≠</mi><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">f_{1,0} =(x, y1) \quad x\ne x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>=</mo><mo>(</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mspace width="1em"/><mi>y</mi><mi mathvariant="normal">≠</mi><mi>y</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">f_{0,1} =(x1, y) \quad y\ne y1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>=</mo><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mspace width="1em"/><mi>x</mi><mi mathvariant="normal">≠</mi><mi>x</mi><mn>1</mn><mi mathvariant="normal">且</mi><mi>y</mi><mi mathvariant="normal">≠</mi><mi>y</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">f_{1,1} =(x,y) \quad x\ne x1 且y\ne y1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mord cjk_fallback">且</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span></span></span></span></li>
</ul>
</blockquote>
<p>dp方程也很好推且很好理解。算是一道优化状态的好题。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
/**/
const int mod = 998244353;
int n, m, t;
int x1, Y1, x2, y2;
int v00, v01, v10, v11;
int f[2][2];
/**/
signed main()
{
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;
	cin &gt;&gt; x1 &gt;&gt; Y1 &gt;&gt; x2 &gt;&gt; y2;
	f[0][0] = 1;
	while(t--)
	{
		v00 = (f[1][0] * (n - 1) % mod + f[0][1] * (m - 1) % mod) % mod;
		v01 = (f[0][1] * (m - 2) % mod + f[1][1] * (n - 1) % mod + f[0][0]) % mod;
		v10 = (f[1][0] * (n - 2) % mod + f[1][1] * (m - 1) % mod + f[0][0]) % mod;
		v11 = (f[1][1] * (n + m - 4) % mod + f[0][1] + f[1][0]) % mod;
		f[0][0] = v00, f[0][1] = v01, f[1][0] = v10, f[1][1] = v11;
	}
	cin &gt;&gt; x1 &gt;&gt; Y1 &gt;&gt; x2 &gt;&gt; y2;
	if(x1 == x2 &amp;&amp; Y1 == y2) cout &lt;&lt; f[0][0];
	else if(x1 == x2 &amp;&amp; Y1 != y2) cout &lt;&lt; f[0][1];
	else if(x1 != x2 &amp;&amp; Y1 == y2) cout &lt;&lt; f[1][0];
	else cout &lt;&lt; f[1][1];
	return 0;
}
</code></pre>
<h1 id="f-simple-operations-on-sequence"><strong>F - Simple Operations on Sequence</strong></h1>
<p>**题意： ** 现有长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，可以对序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>进行以下两种代价分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>的操作，求将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>的最小代价。</p>
<blockquote>
<ul>
<li>opt1：</li>
<li>opt2：</li>
</ul>
</blockquote>
<p><strong>Solution：</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF 1615 global 赛后题解]]></title>
        <id>https://gujinli.github.io/post/cf-1615-global-sai-hou-ti-jie/</id>
        <link href="https://gujinli.github.io/post/cf-1615-global-sai-hou-ti-jie/">
        </link>
        <updated>2021-12-25T07:23:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c-menorah"><a href="https://codeforces.com/contest/1615/problem/C">C - Menorah</a></h1>
<blockquote>
<p>两个01串s1和s2。求最少的操作数把s1变为s2，不能则为-1</p>
<p>操作：固定一个1，其余位全部取反</p>
</blockquote>
<p>我们的目标是让所有的位置变得相同。</p>
<p>考虑两个字符串相同的0**(00)<strong>和1</strong>(11)<strong>的数量，以及不同的0</strong>(01)<strong>和1</strong>(10)**的数量。</p>
<p>一个位置点两次是没有意义的，而连续点两个位置相当于交换了两个位置。（1和0）</p>
<p>所以对于当前不同的，<strong>即01，10</strong>：我们有两种策略：</p>
<ul>
<li>点不同的位置。如果不同的位置的1和0数量相等，即可全部交换。因为点了偶数次所以对初始相等的不造成影响</li>
<li>点相同的位置。相同的位置点奇数次，即可让不同的位置变成相同，那么问题转换成了如何点奇数次使得相同的位置不变。
<ul>
<li>我们只需要让1的数量比0的数量多1，即可在偶数次交换01后使有一个11，而其他的全部不同。</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
/**/
const int N = 1e5 + 5;
int t, n, sc1, sc0, dc1, dc0;
char s1[N], s2[N];
/**/
int main()
{
	read(t);
	while(t--)
	{
		read(n);
		scanf(&quot;%s%s&quot;, s1 + 1, s2 + 1);
		sc1 = sc0 = dc1 = dc0 = 0;
		for(int i = 1; i &lt;= n; i++)
		{
			if(s1[i] == s2[i])
			{
				if(s1[i] == '1') sc1++;
				else sc0++;
			}
			else
			{
				if(s1[i] == '1') dc1++;
				else dc0++;
			}
		}
		int ans = 0x3f3f3f3f;
		if(dc0 == dc1) ans = min(ans, dc0 + dc1);
		if(sc1 == sc0 + 1) ans = min(ans, sc1 + sc0);
		if(ans == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; '\n';
		else cout &lt;&lt; ans &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<h1 id="d-xor-mas-tree"><a href="https://codeforces.com/contest/1615/problem/D">D - X(or)-mas Tree</a></h1>
<blockquote>
<p>给定一个树，边权为-1表示未知。给定m个节点间路径异或和二进制1个数的奇偶性，判断能否构造一个合法的树满足条件</p>
</blockquote>
<ul>
<li>一个性质：设两个数为x,y。二进制下x有a个1，y有b个1。则：
<ul>
<li>a ^ b = num_1(x ^ y) % 2</li>
</ul>
</li>
</ul>
<p>所以对于每个边权，我们只需要考虑其1的个数的奇偶性。把m条边加上后一起遍历判断，不确定的边利用异或的性质输出边权即可</p>
<p>注意这里用了内置的位运算函数，简单介绍一下</p>
<p>__builtin_ffs (unsigned int x)返回x的最后一位1的是从后向前第几位，比如7368（1110011001000）返回4</p>
<p>__builtin_clz (unsigned int x)返回前导的0的个数。</p>
<p>__builtin_ctz (unsigned int x) 返回后面的0个个数，和; builtin_clz相对。</p>
<p>__ builtin_popcount (unsigned int x) 返回二进制表示中1的个数。</p>
<p>__builtin_parity (unsigned int x) 返回x的奇偶校验位，也就是x的1的个数模2的结果。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define vi vector&lt;int&gt;
#define pi pair&lt;int, int&gt;
#define fr(a) freopen(a, &quot;r&quot;, stdin)
#define fo(a) freopen(a, &quot;w&quot;, stdout);
#define mod 998244353
template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;}
template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;}
ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;}
using namespace std;
const int maxn = 200005;
/**/
int t, n, m, err;
int dis[maxn], vis[maxn];
vector&lt;pi&gt;g[maxn];
/**/
void dfs(int u) {
	if(err) return;
	for(auto i:g[u]) {
		int v = i.fi, w = i.se;
		if(dis[v] == -1) {
			dis[v] = dis[u] ^ w;
			dfs(v);
		}
		else if(dis[v] != (dis[u] ^ w)) {
			err = 1;
			return;
		}
	}
}
void solve() {
	err = 0;
	vector&lt; array&lt;int, 3&gt; &gt;ed;
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1; i &lt;= n; i++) {
		g[i].clear();
		dis[i] = -1;
	}
	for(int i = 1; i &lt; n; i++) {
		int u, v, w;
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		ed.pb({u, v, w});
		if(w == -1) continue;
		w = __builtin_parity(w);
		g[u].pb({v, w});
		g[v].pb({u, w});
	}
	for(int i = 1; i &lt;= m; i++) {
		int u, v, w;
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		g[u].pb({v, w});
		g[v].pb({u, w});
	}
	for(int i = 1; i &lt;= n; i++) {
		if(dis[i] == -1) dis[i] = 0, dfs(i);
	}
	if(err) {puts(&quot;NO&quot;); return;}
	puts(&quot;YES&quot;);
	for(auto i: ed) {
		int u = i[0], v = i[1], w = i[2];
		if(w == -1) w = dis[u] ^ dis[v];
		printf(&quot;%d %d %d\n&quot;, u, v, w);
	}
}
int main()
{
	// fr(&quot;test.in&quot;);
	// fo(&quot;test.out&quot;);
	ios::sync_with_stdio(0);cin.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--) {
		solve();
	}
	return 0;
}
</code></pre>
<h1 id="e-purple-crayon"><a href="https://codeforces.com/contest/1615/problem/E">E - Purple Crayon</a></h1>
<blockquote>
<p>一个初始全部为空白节点的树。红（<strong>先手</strong>）蓝两方轮流对其染色：（注：以下操作可以进行任意次）</p>
<ul>
<li>红：选择一个空白子树将其全部染为红色。（注：一回合染色的节点数不能超过k）</li>
<li>蓝：选择任意个空白子树将其全部染为蓝色。（染色数无限制）</li>
</ul>
<p>定义val = w(r-b) ，w：空白节点，r：红色，b：蓝色。</p>
<p>红方想让val最大化，蓝方想让b最小化。求双方均采取最优策略的情况下的val。</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo>−</mo><mi>b</mi><mo>)</mo><mo>(</mo><mi>r</mi><mo>−</mo><mi>b</mi><mo>)</mo><mo>=</mo><mi>r</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo>)</mo><mo>−</mo><mi>b</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">val = (n-r-b)(r-b) = r(n-r)-b(n-b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>首先对于蓝方来说，只需要最大化<strong>b(n-b)</strong> ，即选尽可能多的节点。</p>
<p>红方先选：</p>
<ul>
<li>
<p>k &gt;= 叶 把所有叶节点全选了使得b=0。此时 val = r(n-r)。显然r接近2/n时最小。即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mn>2</mn><mi mathvariant="normal">/</mi><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">叶</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">r = max(min(2/n, k),叶)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">/</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">叶</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>k &lt; 叶 即此时红方没有办法保证蓝方无点可选，显然选择一个叶节点后可以叶 -&gt; 根上的所有路径全部被染色。因此问题变成了求选k个点尽可能多的染色。根据官方题解的做法，我们可以先求出每个点的深度，降序排序后dfs。到达根或一个已染色的节点后返回这条链的长度。将链长降序排序后选择最大的k个即可。</p>
<p>之后剩下的就只能由蓝方任意选择了，如果剩下的所有点&lt;=2/n则全选，如果 &gt; 2/n ，则只需选 2/n个即可。因为b = 2/n时使得结果最小化，且r再选只会使结果更小。（因为已经是负值了）</p>
</li>
</ul>
<blockquote>
<p>关于求这样的链长除了染色以外，从dmyls那里学习的另一种做法如下：</p>
<p>mx[u] 表示 u 到最底端的链长。每次遍历到u时，将所有的mx[v]存进一个vector中，最大的作为u的链继续向上延伸，其余的加入最后统计的链长里即可。</p>
<p>非常妙www，虽然会因为排序操作使时间复杂度变大，但毫无影响。</p>
</blockquote>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define vi vector&lt;int&gt;
#define pi pair&lt;int, int&gt;
#define mod 998244353
template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;}
template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;}
ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;}
using namespace std;
const int maxn = 200005;
/**/
int n, k, mx[maxn], r, b;
vi eg[maxn];
vi cur;
/**/
void dfs(int u, int fa)
{
	if(eg[u].size() == 1 &amp;&amp; fa) {
		mx[u] = 1;
		return;
	}
	vi cr;
	for(auto v : eg[u]) {
		if(v == fa) continue;
		dfs(v, u);
		cr.pb(mx[v]);
	}
	sort(cr.begin(), cr.end());
	mx[u] = cr[cr.size() - 1] + 1;
	for(int i = 0; i &lt; cr.size() - 1; i++) cur.pb(cr[i]);
}
int main()
{
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	cin &gt;&gt; n &gt;&gt; k;
	for(int i = 1; i &lt; n; i++) {
		int u, v;
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		eg[u].pb(v), eg[v].pb(u);
	}
	// puts(&quot;ok1&quot;);
	dfs(1, 0);
	cur.pb(mx[1]);
	sort(cur.begin(), cur.end());
	reverse(cur.begin(), cur.end());
	if(k &gt; cur.size()) {
		b = 0;
		r = min(k, n / 2);
		if(r &lt; cur.size()) r = cur.size();
	}
	else {
		r = k;
		b = n;
		for(int i = 0; i &lt; k; i++) b -= cur[i];
		if(b &gt; n / 2) b = n / 2;
	}
	ll ans = 1ll * (n - r - b) * (r - b);
	cout &lt;&lt; ans &lt;&lt; '\n';
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF 1619 div3 赛后题解]]></title>
        <id>https://gujinli.github.io/post/cf-762-div3-sai-hou-ti-jie/</id>
        <link href="https://gujinli.github.io/post/cf-762-div3-sai-hou-ti-jie/">
        </link>
        <updated>2021-12-21T12:00:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="a-square-string">A Square String?</h1>
<p><strong>题意：</strong> 判断一个串是否可以由两个串拼接而成。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
int t;
string s;
/**/
int main()
{
    read(t);
    while(t--)
    {
        cin &gt;&gt; s;
        int n = s.length();
        if(n &amp; 1) {puts(&quot;NO&quot;); continue;}
        if(s.substr(0, n/2) == s.substr(n/2, n/2)) puts(&quot;YES&quot;);
        else puts(&quot;NO&quot;);
    }
    return 0;
}
</code></pre>
<h1 id="b-squares-and-cubes">B Squares and Cubes</h1>
<p><strong>题意：</strong> 判断n以内有多少正整数是平方/立方数。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
/**/
int t, n, ans;
/**/
signed main()
{
    read(t);
    while(t--)
    {
        read(n); ans = 0;
        for(int i = 1; i * i &lt;= n; i++)
        {
            ans++;
            int num = i * i * i;
            if(num &gt; n) continue;
            int x = sqrt(num);
            if(x * x == num) continue;
            ans++;
        }
        cout &lt;&lt; ans &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>
<h1 id="c-wrong-addition">C Wrong Addition</h1>
<p><strong>题意：</strong> 定义傻子加法为：按位相加后把结果直接写在答案里。即：17236 + 03465 = 1106911</p>
<p><strong>Solution：</strong> 注意细节简单模拟即可。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define PII pair&lt;int, int&gt;
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
/**/
const int N = 50;
int t;
char a[N], s[N];
/**/
int main()
{
    read(t);
    while(t--)
    {
        scanf(&quot;%s%s&quot;,a+1,s+1);
        int l1 = strlen(a + 1), l2 = strlen(s + 1);
        vector&lt;int&gt;ans;
        int i, j;
        for(i = l2, j = l1; i; i--)
        {
            int num1, num2;
            if(j) num1 = a[j--] - '0';
            else num1 = 0;
            num2 = s[i] - '0';
            if(num1 &gt; num2 &amp;&amp; i == 1) break;
            if(num1 &gt; num2) num2 = num2 + 10 * (s[--i] - '0');
            if(num2 - num1 &gt; 9 || num2 - num1 &lt; 0) break;
            ans.push_back(num2 - num1);
        }
        if(j != 0 || i != 0) {puts(&quot;-1&quot;);continue;}
        int sz = ans.size();
        bool flag = 0;
        for(int k = sz-1; k &gt;= 0; k--)
        {
            if(!flag &amp;&amp; !ans[k]) continue;
            flag = 1;
            cout &lt;&lt; ans[k];
        }
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
<h1 id="d-new-years-problem">D New Year's Problem</h1>
<p><strong>题意：</strong></p>
<p>n个人。m个商店。</p>
<p>每个商店有对应n个人的n个礼物，每个礼物有一个满意度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> ，选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个商店使得：所有人能/获得的最大满意度的最小值最大。</p>
<p><strong>Solution：</strong></p>
<p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>e</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">lie[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 表示第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个人的最大满意度。</p>
<p>显然，n个人选择n个商店的话，只需要把n个人最大满意度所在的商店选择即可。</p>
<p>根据鸽巢原理，n个人选择n-1的话，必然有两列的最优值在同一行。</p>
<p>我们枚举商店，选择一个商店记录其最大和次大，除去这两个人后，剩下的全部选择最大值即可。</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
const int N = 1e5 + 5;
int t, n, m, ans, lie[N], pos1, pos2;
int main()
{
    read(t);
    while(t--)
    {
        read(m); read(n); ans = 0;
        vector&lt;int&gt;v[m+2];
        for(int i = 1; i &lt;= m; i++)
        {
            v[i].push_back(0);
            for(int j = 1, x; j &lt;= n; j++)
            {
                lie[j] = 0;
                read(x);
                v[i].push_back(x);
            }
        }
        for(int i = 1; i &lt;= n; i++)
        {
            for(int j = 1; j &lt;= m; j++)
            {
                lie[i] = max(lie[i], v[j][i]);
            }
        }
        for(int i = 1; i &lt;= m; i++)
        {
            pos1 = pos2 = 0;
            for(int j = 1; j &lt;= n; j++)
            {
                if(v[i][j] &gt; v[i][pos1]) pos2 = pos1, pos1 = j;
                else if(v[i][j] &gt; v[i][pos2]) pos2 = j;
            }
            int maxnum = min(v[i][pos1], v[i][pos2]);
            for(int j = 1; j &lt;= n; j++)
            {
                if(j == pos1 || j == pos2) continue;
                maxnum = min(maxnum, lie[j]);
            }
            ans = max(ans, maxnum);
        }
        cout &lt;&lt; ans &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>
<h1 id="e-mex-and-increments">E MEX and Increments</h1>
<p><strong>题意：</strong> 给定一个长度为n的数列满足每个数都&lt;=n。每次操作可以将某个数+1。求使序列mex = {0...n} 的最小操作次数。</p>
<p><strong>Solution：</strong> 当我们求 i 时， 如果 0...i-1 所有数都有，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">ans[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> = 当前数列中 i 的数量。（开个桶记录即可）</p>
<p>如果求到第 i 个，没有 i 则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">ans[i] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ，同时从前面的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">tot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 中找一个离得最近且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">&gt;2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的数，将其变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
const int N = 2e5 + 5;
int t, n, tot[N], a[N], lst, rec, pre[N];
signed main()
{
	read(t);
	while(t--)
	{
		read(n);
		memset(tot, 0, sizeof(tot));
		for(int i = 1; i &lt;= n; i++)
		{
			read(a[i]);
			tot[a[i]]++;
			pre[i] = i - 1;
		}
		pre[0] = -1;
		sort(a + 1, a + 1 + n);
		lst = -1, rec = 0;
		for(int i = 0; i &lt;= n; i++)
		{
			if(tot[i])
			{
				cout &lt;&lt; rec + tot[i] &lt;&lt; ' ';
				if(tot[i] &gt; 1) pre[i] = lst, lst = i;
			}
			else
			{
				cout &lt;&lt; rec &lt;&lt; ' ';
				if(lst == -1 || tot[lst] &lt; 2)
				{
					for(int j = i+1; j &lt;= n; j++) cout &lt;&lt; -1 &lt;&lt;' ';
					break;
				}
				rec += i - lst;
				tot[lst]--;
				while(lst != -1 &amp;&amp; tot[lst] &lt; 2) lst = pre[lst];
				pre[i] = lst;
				tot[i]++;
			}
		}
		puts(&quot;&quot;);
	}
	return 0;
}
</code></pre>
<h1 id="f-lets-play-the-hat">F. Let's Play the Hat?</h1>
<p><strong>题意：</strong> n个人m张桌子玩k次游戏。每个人必须玩k次游戏。每个桌子的人数都是 n/m （上取整 或 下取整）。</p>
<p>定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个人在人数为 n/m(上取整) 的桌子上玩的游戏次数。对任意 $ i, j $ 满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>b</mi><mi>i</mi></msub><mo>−</mo><msub><mi>b</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|b_i - b_j| &lt;= 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p><strong>Solution：</strong> 首先，m张桌子分给n个人，显然每张桌子的人数是确定的——</p>
<p>大桌为n%m个，小桌为 m - n%m个。（每张桌子先坐 n/m（下取整）个人，剩下的 n%m 个人随便挑一个坐）</p>
<p>我们要使每个人在大桌上坐的次数相差不超过1。策略是这样的：</p>
<p>每次让坐在大桌上次数较少的人坐大桌，坐不满从较多的人补。这样显然可以保证相差不超过1。</p>
<p>实现的话可以考虑利用vector的rotate来滚动选择的人，每次坐大桌的人都让其移动到整个序列的最后排队。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
const int N = 2e5 + 5;
int t, n, m, k;
int main()
{
    read(t);
    while(t--)
    {
        read(n); read(m); read(k);
        vector&lt;int&gt;v(n);
        for(int i = 0; i &lt; n; i++) v[i] = i + 1;
        int bt = n % m, bn = ceil(1.0 * n / m), sn = n / m;
        for(int i = 1; i &lt;= k; i++)
        {
            int pos = 0;
            for(int j = 1, num; j &lt;= m; j++)
            {
                if(j &lt;= bt) num = bn; else num = sn;
                cout &lt;&lt; num &lt;&lt; ' ';
                while(num--) cout &lt;&lt; v[pos++] &lt;&lt; ' ';
                puts(&quot;&quot;);
            }
            rotate(v.begin(), v.begin() + bn * bt, v.end());
        }
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
<h1 id="g-unusual-minesweeper">G. Unusual Minesweeper</h1>
<p><strong>题意：</strong> 有n个地雷。已知地雷爆炸半径k （按十字形爆炸）和每个地雷的坐标即爆炸时间。</p>
<p>一个地雷爆炸后会瞬间引爆 十字形 上的所有其他地雷，定义该传递的时间是瞬间完成的（即0s）。</p>
<p>同时，我们每一秒还可以选择一个未爆炸的地雷点燃，求最快几s可以让所有的地雷爆炸。（从第0s开始，每s一个）</p>
<p><strong>Solution：</strong> 用并查集将互相影响的所有地雷丢进一个集合，得到每个集合的最小爆炸时间。</p>
<p>将该时间递增排序后，枚举第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">i ... n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">n</span></span></span></span> 个地雷是人为引爆的 则时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">max(n-i, ti[i-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
const int N = 2e5 + 5;
int t, n, k, ans, tot[N], fa[N], ti[N];
bool vis[N];
struct node { int x, y, t, id; }a[N];
inline bool cmp1(node i, node j)
{
    if(i.x == j.x) return i.y &lt; j.y;
    return i.x &lt; j.x;
}
inline bool cmp2(node i, node j)
{
    if(i.y == j.y) return i.x &lt; j.x;
    return i.y &lt; j.y;
}
inline int find(int x) {return x == fa[x] ? x : fa[x] = find(fa[x]);}
inline void merge(int i, int j)
{
    int f1 = find(i), f2 = find(j);
    if(f1 == f2) return;
    if(ti[f1] &lt; ti[f2]) fa[f2] = f1;
    else fa[f1] = f2;
}
int main()
{
    read(t);
    while(t--)
    {
        read(n); read(k); tot[0] = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            read(a[i].x); read(a[i].y); read(a[i].t); a[i].id = i;
            fa[i] = i; ti[i] = a[i].t; vis[i] = 0;
        }
        sort(a + 1, a + 1 + n, cmp1);
        for(int i = 1; i &lt; n; i++) if(a[i].x == a[i + 1].x &amp;&amp; a[i + 1].y - a[i].y &lt;= k) merge(a[i].id, a[i + 1].id);
        sort(a + 1, a + 1 + n, cmp2);
        for(int i = 1; i &lt; n; i++) if(a[i].y == a[i + 1].y &amp;&amp; a[i + 1].x - a[i].x &lt;= k) merge(a[i].id, a[i + 1].id);
        for(int i = 1; i &lt;= n; i++)
        {
            int f1 = find(i);
            if(!vis[f1]) vis[f1] = 1, tot[++tot[0]] = ti[f1];
        }
        sort(tot + 1, tot + 1 + tot[0]);
        ans = min(tot[tot[0]], tot[0] - 1);
        for(int i = tot[0]; i &gt;= 1; i--)
        {
            int num = tot[0] - i + 1;
            ans = min(ans, max(num - 1, tot[i - 1]));
        }
        cout &lt;&lt; ans &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>
<h1 id="h-permutation-and-queries">H. Permutation and Queries</h1>
<p><strong>题意：</strong> 长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的一个排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p_{i} (1\le i \le n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> ，对其进行两种类型的  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 次 操作。</p>
<blockquote>
<ul>
<li>
<p>OPT 1 x y ： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>w</mi><mi>a</mi><mi>p</mi><mo>(</mo><msub><mi>p</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>p</mi><mi>y</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">swap(p_x, p_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>OPT 2 i k :  print the number that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> will become if we assign <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">i=p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> times.</p>
</li>
</ul>
</blockquote>
<p><strong>Solution：</strong> 待补。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[漫漫ACM之路]]></title>
        <id>https://gujinli.github.io/post/man-man-acm-zhi-lu/</id>
        <link href="https://gujinli.github.io/post/man-man-acm-zhi-lu/">
        </link>
        <updated>2021-12-06T07:52:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="图论">图论：</h1>
<p>**生成树问题： **</p>
<ul>
<li>最小生成树
<ul>
<li>次小生成树(非严格/严格)</li>
<li>瓶颈生成树</li>
<li>kruscal重构树</li>
</ul>
</li>
<li>最小树形图</li>
<li>最小直径生成树</li>
</ul>
<p><strong>树上问题:</strong></p>
<ul>
<li><strong>基础性质</strong> (直径,重心)</li>
<li>最近公共祖先(LCA)</li>
<li>树上启发式合并(dsu on tree)</li>
<li>虚树</li>
<li>树链剖分
<ul>
<li>重链剖分</li>
<li>长链剖分</li>
</ul>
</li>
<li>树分治:
<ul>
<li>点分治</li>
<li>边分治</li>
<li>点分树</li>
<li>动态树分治</li>
</ul>
</li>
<li>树同构:
<ul>
<li>AHU</li>
<li>树哈希</li>
</ul>
</li>
</ul>
<p><strong>最短路问题：</strong></p>
<ul>
<li>Johnson 全源最短路径算法</li>
<li>分层图最短路</li>
<li>k短路</li>
<li>同余最短路</li>
<li>差分约束</li>
</ul>
<p><strong>连通问题:</strong></p>
<ul>
<li>
<p>强连通分量</p>
</li>
<li>
<p>双连通分量</p>
</li>
<li>
<p>割点和桥</p>
</li>
<li>
<p>圆方树</p>
</li>
<li>
<p><strong>2-SAT</strong></p>
</li>
</ul>
<p><strong>特殊图问题:</strong></p>
<ul>
<li>欧拉图</li>
<li>哈密顿图</li>
<li><strong>二分图</strong>
<ul>
<li>图的着色</li>
</ul>
</li>
<li>平面图</li>
</ul>
<p><strong>特殊应用:</strong></p>
<ul>
<li>斯坦纳树</li>
<li>矩阵树定理</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杂记]]></title>
        <id>https://gujinli.github.io/post/za-ji/</id>
        <link href="https://gujinli.github.io/post/za-ji/">
        </link>
        <updated>2021-12-01T10:59:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="bitset">bitset</h1>
<p>bitset是像bool数组一样的东西。但每个位置只占1bit。<br>
一定程度上节省了空间和时间，一般来说会让算法复杂度/32。</p>
<p><strong>定义与初始化：</strong></p>
<ul>
<li>头文件：<code>#include&lt;bitset&gt;</code></li>
<li>定义时需指明所占用的空间（类数组）：<code>bitset&lt;114514&gt;bit;</code></li>
<li>初始化可以用<strong>string</strong>或<strong>int</strong>（整数类型）：</li>
</ul>
<pre><code class="language-c++">bitset&lt;23&gt;bit (string(&quot;11101001&quot;));
bitset&lt;23&gt;bit = 233;
</code></pre>
<p><strong>常用函数：</strong></p>
<blockquote>
<pre><code>bit.size()      返回大小（位数）
bit.count()     返回1的个数
bit.any()       返回是否有1
bit.none()      返回是否没有1
bit.set()       全都变成1
bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！） 
bit.set(p, x)   将第p + 1位变成x
bit.reset()     全都变成0
bit.reset(p)    将第p + 1位变成0
bit.flip()      全都取反
bit.flip(p)     将第p + 1位取反
bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错
bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错
bit.to_string() 返回它转换为string的结果
</code></pre>
</blockquote>
<h1 id="杂stl">杂stl</h1>
<ul>
<li><strong>rotate</strong> ：用于vector</li>
</ul>
<blockquote>
<p>rotate(a, b, c) 把 b ~ c 的元素放到 a 前面。 把[a ~ b) 和 [b, c) 互换</p>
</blockquote>
<ul>
<li>高效位运算</li>
</ul>
<p>__builtin_ffs (unsigned int x)返回x的最后一位1的是从后向前第几位，比如7368（1110011001000）返回4</p>
<p>__builtin_clz (unsigned int x)返回前导的0的个数。</p>
<p>__builtin_ctz (unsigned int x) 返回后面的0个个数，和; builtin_clz相对。</p>
<p>__ builtin_popcount (unsigned int x) 返回二进制表示中1的个数。</p>
<p>__builtin_parity (unsigned int x) 返回x的奇偶校验位，也就是x的1的个数模2的结果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ICPC2021沈阳 部分题解]]></title>
        <id>https://gujinli.github.io/post/icpc2021-shen-yang-bu-fen-ti-jie/</id>
        <link href="https://gujinli.github.io/post/icpc2021-shen-yang-bu-fen-ti-jie/">
        </link>
        <updated>2021-12-01T06:01:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="e-edward-gaming-the-champion签到题">E. Edward Gaming, the Champion(签到题)</h1>
<p><strong>题意：</strong> 求一个字符串s中有多少个&quot;edgnb&quot;</p>
<p><strong>Solution：</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>D</mi><mi>G</mi><mi>N</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">EDGNB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
/**/
const int N = 2e5 + 5;
char s[N];
/**/
int main()
{
	scanf(&quot;%s&quot;, s);
	int len = strlen(s), ans = 0;
	for(int i = 0; i &lt; len; i++)
	{
		if(i+4&gt;=len) break;
		if(s[i]=='e'&amp;&amp;s[i+1]=='d'&amp;&amp;s[i+2]=='g'&amp;&amp;s[i+3]=='n'&amp;&amp;s[i+4]=='b') ans++, i = i + 4;
	}
	cout&lt;&lt;ans;
	return 0;
}

</code></pre>
<h1 id="f-encoded-strings-i签到题模拟">F. Encoded Strings I（签到题/模拟）</h1>
<p><strong>题意：</strong> 队友A的，待补。</p>
<p><strong>Solution：</strong> 队友A的，待补。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define il inline
#define ll long long
#define Max 1005
#define int ll
using namespace std;
il ll read()
{
	char c=getchar();
	ll x=0,f=1;
	while(c&gt;'9'||c&lt;'0')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c&gt;='0'&amp;&amp;c&lt;='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
int n,a[Max],c[Max],id[Max];
char s[Max],t[Max][Max];
il bool cmp(int x,int y)
{
	int l=min(strlen(t[x]+1),strlen(t[y]+1));
	for(int i=1;i&lt;=l;i++)
	{
		if(t[x][i]&lt;t[y][i]) return 0;
		if(t[x][i]&gt;t[y][i]) return 1;
	}
	return strlen(t[x]+1)&gt;strlen(t[y]+1);
}
signed main()
{
	n=read();
	scanf(&quot;%s&quot;,s+1);
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=1;j&lt;=26;j++) c[j]=0;
		int tot=0;
		for(int j=i;j&gt;=1;j--)
		{
			if(!c[s[j]-'a'+1]) t[i][j]=tot+'a',c[s[j]-'a'+1]=++tot;
			else t[i][j]=c[s[j]-'a'+1]+'a'-1;
			//cout&lt;&lt;j&lt;&lt;' '&lt;&lt;c[s[j]-'a'+1]&lt;&lt;' '&lt;&lt;s[j]&lt;&lt;' '&lt;&lt;tot&lt;&lt;&quot; qwq\n&quot;;
		}
	}
	//for(int i=1;i&lt;=n;i++) puts(t[i]+1);
	for(int i=1;i&lt;=n;i++) id[i]=i;
	sort(id+1,id+1+n,cmp);
	puts(t[id[1]]+1);
}

</code></pre>
<h1 id="j-luggage-lockbfs">J. Luggage Lock（bfs）</h1>
<p><strong>题意：</strong> 一个四位数密码。给定起始状态 <strong>A</strong> 和终止状态 <strong>B</strong> 。每次可以选择一段区间<strong>向上拧或向下拧</strong>（即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn><mi mathvariant="normal">/</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1/-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">+</span><span class="mord">1</span><span class="mord">/</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>）。</p>
<p>求由A变为B的最小操作次数。</p>
<p><strong>Solution：</strong> 因为所有的两组状态都可以转化成 <strong>起始状态为 0000</strong>。因此对于 <strong>0000</strong> 开始，其实只有 <strong>10000</strong> 种状态。</p>
<p>预处理：利用 <strong>bfs</strong> 求最少步数。同时对已经得到的状态进行标记即可。</p>
<p>然后即可对每组询问 <strong>O(1)</strong> 输出。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define PII pair&lt;string,int&gt;
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
/**/
const string opt[15] = {&quot;0001&quot;,&quot;0011&quot;,&quot;0111&quot;,&quot;1111&quot;,&quot;0010&quot;,&quot;0110&quot;,&quot;1110&quot;,&quot;0100&quot;,&quot;1100&quot;,&quot;1000&quot;};
int vis[10005], ans[10005];
/**/
inline int get(string s)
{
	int ret = 0;
	for(int i=0;i&lt;4;i++) ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+s[i]-'0';
	return ret;
}
inline string work(string s,int p,int flag)
{
	string ret = s;
	for(int i=0;i&lt;4;i++)
	{
		if(opt[p][i]=='0') continue;
		ret[i]=(ret[i]-'0'+flag+10)%10+'0';
	}
	return ret;
}
int main()
{
	queue&lt;PII&gt;q;
	q.push(PII(&quot;0000&quot;,0));
	vis[0] = 1;
	while(!q.empty())
	{
		PII t = q.front(); q.pop();
		string u = t.first;
		int step = t.second;
		for (int i = 0; i &lt; 10; i++)
		{

			string s1 = work(u,i,1);
			string s2 = work(u,i,-1);
			int num1 = get(s1), num2 = get(s2);
			if(!vis[num1])
			{
				vis[num1]=1;
				ans[num1]=step + 1;
				q.push(PII(s1, step + 1));
			}
			if(!vis[num2]) vis[num2] = 1, ans[num2] = step + 1, q.push(PII(s2, step + 1));
		}
	}
	int t;
	read(t);
	string S1, S2, T;
	while(t--)
	{
		cin &gt;&gt; S1 &gt;&gt; S2;
		int ret = 0;
		for(int i=0;i&lt;4;i++)
		{
			ret = ret * 10 + (S2[i]-S1[i]+10)%10;
		}
		cout &lt;&lt; ans[ret] &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<h1 id="b-bitwise-exclusive-or-sequence铜牌题">B. Bitwise Exclusive-OR Sequence（铜牌题）</h1>
<p><strong>题意：</strong> 一段长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数。给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 组关系。每组关系 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u,v,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> 描述了：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>u</mi></msub><mo>⊕</mo><msub><mi>a</mi><mi>v</mi></msub><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">a_u \oplus a_v=w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></p>
<p>求这组数 各元素和 的最小值。</p>
<p><strong>Solution：</strong> 可以根据每组关系建边，随意以一个有出边的点为树根进行遍历。</p>
<p>定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dis[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span> 为 从根节点到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的边权异或和。根据异或性质易知：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>r</mi><mi>t</mi></mrow></msub><mo>⊕</mo><msub><mi>a</mi><mi>u</mi></msub><mo>=</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">a_{rt} \oplus a_u = dis_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>如果出现两个不同值的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dis[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span> 则数据出现矛盾输出 <strong>-1</strong>。</p>
<p>对该森林的其中一个树，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">tot[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 表示所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dis[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span> 的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 位为1的数量。超过一半则让根该位为<strong>1</strong>更优，否则让根该位为<strong>0</strong>。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; }
/**/
const int N = 1e5 + 5, M = 4e5 + 5;
int n, m, head[N], cnt, dis[N], tot[N], vis[N], sum;
bool err;
ll ans;
struct edge
{
	int nxt, to, w;
}e[M];
/**/
inline void add(int u, int v, int w)
{
	e[++cnt] = (edge){head[u], v, w};
	head[u] = cnt;
}
void dfs(int u, int fa, int ti)
{
	if(err) return;
	for(int i = head[u]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		if(v == fa) continue;
		if(vis[v])
		{
			if((dis[u] ^ e[i].w) == dis[v]) continue;
			else {err = 1; return;}
		}
		vis[v] = ti;
		dis[v] = (dis[u] ^ e[i].w);
		sum++;
		for(int j = 0; j &lt;= 30; j++)
		{
			if(dis[v] &amp; (1&lt;&lt;j)) tot[j]++;
		}
		dfs(v, u, ti);
		if(err) return;
	}
}
int main()
{
	read(n); read(m);
	for(int i = 1, u, v, w; i &lt;= m; i++)
	{
		read(u); read(v); read(w);
		if(u==v)
		{
			if(w) err = 1;
			continue;
		}
		add(u, v, w);
		add(v, u, w);
	}
	if(err) {puts(&quot;-1&quot;);return 0;}
	for(int i = 1; i &lt;= n; i++)
	{
		if(!head[i]) continue;
		if(vis[i]) continue;
		vis[i] = i;
		dfs(i, 0, i); sum++;
		for(int j = 0; j &lt;= 30; j++)
		{
			ans += 1ll * min(tot[j], sum - tot[j]) * (1 &lt;&lt; j);
			tot[j] = 0;
		}
		sum = 0;
		if(err) {puts(&quot;-1&quot;); return 0;}	
	}
	if(err) {puts(&quot;-1&quot;); return 0;}
	cout &lt;&lt; ans &lt;&lt; '\n';
	return 0;
}
</code></pre>
<h1 id="l-perfect-matchings树形dp容斥">L. Perfect Matchings（树形dp+容斥）</h1>
<p><strong>题意：</strong> 队友A的，待补。</p>
<p><strong>Solution：</strong> 队友A的，待补。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define il inline
#define ll long long
#define Max 4010
#define Mod 998244353
#define int ll
using namespace std;
il ll read()
{
	char c=getchar();
	ll x=0,f=1;
	while(c&gt;'9'||c&lt;'0')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c&gt;='0'&amp;&amp;c&lt;='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
struct node
{
	int t,nt;
}e[Max&lt;&lt;1];
int n,head[Max],tot,f[Max][Max][2],g[Max],sz[Max],ans;
il void add(int u,int v)
{
	e[++tot].t=v;
	e[tot].nt=head[u];
	head[u]=tot;
}
il void dfs(int u,int fa)
{
	sz[u]=1;
	for(int i=head[u];i;i=e[i].nt)
	{
		int v=e[i].t;
		if(v==fa) continue;
		dfs(v,u);
		sz[u]+=sz[v];
	}
	int s=1;
	//f[u][0][0]=1;
	f[u][0][0]=1;
	for(int i=head[u];i;i=e[i].nt)
	{
		int v=e[i].t;
		if(v==fa) continue;
		for(int j=s/2+1;j&gt;=0;j--)
		{
			for(int k=1;k&lt;=sz[v]/2+1;k++)
			{
				//if(j==0&amp;&amp;k==0) continue;
				f[u][j+k][0]=(f[u][j+k][0]+f[u][j][0]*f[v][k][0]+f[u][j][0]*f[v][k][1])%Mod;
				//f[u][0][0]=1;
				f[u][j+k][1]=(f[u][j+k][1]+f[u][j][0]*f[v][k-1][0]+f[u][j][1]*(f[v][k][0]+f[v][k][1]))%Mod;
				//cout&lt;&lt;u&lt;&lt;' '&lt;&lt;v&lt;&lt;' '&lt;&lt;j&lt;&lt;' '&lt;&lt;k&lt;&lt;' '&lt;&lt;f[1][1][1]&lt;&lt;&quot; qwq\n&quot;;
			}
		}
		s+=sz[v];
	}
}
signed main()
{
	n=read()*2;
	for(int i=1;i&lt;n;i++)
	{
		int u=read(),v=read();
		add(u,v),add(v,u);
	}
	g[0]=1;
	for(int i=2;i&lt;=n;i+=2) g[i]=(i-1)*g[i-2]%Mod;
	dfs(1,0);
	//for(int i=0;i&lt;=n/2;i++) cout&lt;&lt;f[1][i][1]&lt;&lt;' '&lt;&lt;f[1][i][0]&lt;&lt;endl;
	for(int i=0;i&lt;=n/2;i++)
	{
		ans=ans+(g[n-i*2]*(f[1][i][1]+f[1][i][0])%Mod*(i&amp;1?-1:1)+Mod);
		ans=(ans+Mod)%Mod;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}

</code></pre>
<h1 id="m-string-problemkmp">M. String Problem（KMP）</h1>
<p><strong>题意：</strong> 给定一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的字符串s。输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(l_i, r_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 表示：</p>
<p>对 s 的前缀 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mn>1...</mn><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{1...i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中字典序最大的子串。</p>
<p><strong>Solution：</strong> 首先容易得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">r_i = i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>。然后做了一个神奇的 <strong>KMP</strong> 。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e6 + 5;
char s[N];
int nxt[N];
int main()
{
	scanf(&quot;%s&quot;, s + 1);
	int len = strlen(s + 1);
	puts(&quot;1 1&quot;);
	int pos = 1, j = 1;
	for(int i = 2; i &lt;= len; i++)
	{
		while(j &amp;&amp; s[i] &gt; s[pos + nxt[j]])
		{
			pos += (j - nxt[j]);
			j = nxt[j];
		}
		if(j &amp;&amp; s[i] == s[pos + nxt[j]])
		{
			j++;
			nxt[j] = nxt[j - 1] + 1;
		}
		else nxt[++j] = 0;
		printf(&quot;%d %d\n&quot;, pos, i);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>