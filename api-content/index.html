{"posts":[{"title":"ccltime103b C 贪心","content":"C.Optimal Sorting 选择一段连续区间sort的代价是这段区间的最大值-最小值。求把整个数列sort的最小代价 一整段区间分开sort更优 当且仅当 后面所有数的最小值 &gt; 当前最大值。即产生了一段空隙 因为当前最大值如果大于后面所有数的最小值的话，必然要合并在一起sort。 维护后缀最小值从前向后枚举即可。复杂度 O(n) #include &lt;bits/stdc++.h&gt; #define ll long long #define mp make_pair #define fi first #define se second #define pb push_back #define vi vector&lt;int&gt; #define pi pair&lt;int, int&gt; #define fr(a) freopen(a, &quot;r&quot;, stdin) #define fo(a) freopen(a, &quot;w&quot;, stdout); #define mod 998244353 template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;} template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;} ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;} using namespace std; const int maxn = 200005; /**/ int t, n, a[maxn], mi[maxn]; /**/ int main() { // fr(&quot;test.in&quot;); ios::sync_with_stdio(0);cin.tie(0); cin &gt;&gt; t; while(t--) { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } mi[n] = a[n]; for(int i = n - 1; i &gt;= 1; i--) { mi[i] = min(mi[i + 1], a[i]); } int ans = 0, maxnum = 0, minnum = 0x3f3f3f3f; mi[n + 1] = INT_MAX; for(int i = 1; i &lt;= n; i++) { maxnum = max(maxnum, a[i]); minnum = min(minnum, a[i]); if(mi[i + 1] &gt; maxnum) { ans += maxnum - minnum; maxnum = 0; minnum = 0x3f3f3f3f; } } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0; } ","link":"https://gujinli.github.io/post/ccltime103b-c-tan-xin/"},{"title":"ccinfi21C 构造","content":"C. Tug of War 题意： A队有n人，B队有m人，给定了每个人的能力值ai和bi。A队按照(a1...n)的顺序出场，获胜的人留在场上，输了的人离场，平局都立场。求B队能否获胜，如果能的话，输出字典序最小的排列。 Solution： 将B队降序排列。令p1表示A当前的人，p2表示B当前的人。用双指针找出B获胜需要的人，将剩余的人升序输出，获胜需要的人降序输出即可。 证明见官方题解： #include &lt;bits/stdc++.h&gt; #define ll long long // #define int ll #define mp make_pair #define fi first #define se second #define pb push_back #define vi vector&lt;int&gt; #define pi pair&lt;int, int&gt; #define vpii vector&lt;pi&gt; #define il inline #define ri register #define all(a) a.begin(), a.end() #define fr(a) freopen(a, &quot;r&quot;, stdin) #define fo(a) freopen(a, &quot;w&quot;, stdout); #define mod 998244353 template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;} template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;} ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;} using namespace std; const int maxn = 1000005; /**/ int n, m, a[maxn], b[maxn]; /**/ il bool cmp(int x, int y) { return x &gt; y;} il void solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;b[i]); sort(b + 1, b + 1 + m, cmp); int p1 = 1, p2 = 1, err = 0; while(p1 &lt;= n &amp;&amp; p2 &lt;= m) { if(a[p1] &gt; b[p2]) { err = 1; break; } else if(a[p1] &lt; b[p2]) { ++p1; else ++p1, ++p2; } if(p2 &gt; m || err) {printf(&quot;NO\\n&quot;); return;} printf(&quot;YES\\n&quot;); for(int i = m; i &gt; p2; i--) cout &lt;&lt; b[i] &lt;&lt; ' '; for(int i = 1; i &lt;= p2; i++) cout &lt;&lt; b[i] &lt;&lt; ' '; puts(&quot;&quot;); } signed main() { int T; cin &gt;&gt; T; while(T--) { solve(); } return 0; } ","link":"https://gujinli.github.io/post/ccinfi21c-gou-zao/"},{"title":"ccinfi21b 数学/构造","content":"B. Dalgona Treat 题意： 求n个平方数相加得到一个完全平方数，数的种类不能超过10 Solution： n2=(n−2)2∗1+22∗(n−1)n^2=(n-2)^2*1+2^2*(n-1)n2=(n−2)2∗1+22∗(n−1)。 小于3的情况特判直接输出。注意n=4n=4n=4的时候，有n−2=2n-2=2n−2=2，同样特判处理 #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; int t; int n; int main() { cin &gt;&gt; t; while(t--) { cin &gt;&gt; n; if(n == 1) puts(&quot;1\\n1 1&quot;); else if(n == 2) puts(&quot;2\\n3 1\\n4 1&quot;); else if(n == 4) puts(&quot;1\\n1 4&quot;); else { printf(&quot;2\\n2 %d\\n&quot;, n - 1); printf(&quot;%d 1\\n&quot;, n - 2); } } return 0; } ","link":"https://gujinli.github.io/post/ccinfi21b-shu-xue-gou-zao/"},{"title":"abc232E dp/线性/状态优化","content":"E - Rook Path 题意： 一个n∗mn*mn∗m的棋盘。初始点在 (x1,y1)(x1,y1)(x1,y1) ， 求通过 kkk 次移动后到达(x2,y2)(x2,y2)(x2,y2)的方案数。 注：每次移动可以 移至当前列/当前行的任意一点。（不能站着不动） Solution： 首先可以得出简单dp方程： fi,j,k=fi,j,k=∑j2j2≠jfi,j2,k−1+∑i2i2≠ifi2,j,k−1f_{i,j,k} = f_{i,j,k}=\\sum_{j2}^{j2\\ne j}f_{i,j2,k-1} + \\sum_{i2}^{i2\\ne i}f_{i2,j,k-1} fi,j,k​=fi,j,k​=j2∑j2​=j​fi,j2,k−1​+i2∑i2​=i​fi2,j,k−1​ 简单手模之后我们可以发现一个显然的规律就是，对于一个kkk值，fi,jf_{i,j}fi,j​只会有四个不同的取值，分别对应： f0,0=(x1,y1)f_{0,0} =(x1, y1)f0,0​=(x1,y1) f1,0=(x,y1)x≠x1f_{1,0} =(x, y1) \\quad x\\ne x1f1,0​=(x,y1)x​=x1 f0,1=(x1,y)y≠y1f_{0,1} =(x1, y) \\quad y\\ne y1f0,1​=(x1,y)y​=y1 f1,1=(x,y)x≠x1且y≠y1f_{1,1} =(x,y) \\quad x\\ne x1 且y\\ne y1f1,1​=(x,y)x​=x1且y​=y1 dp方程也很好推且很好理解。算是一道优化状态的好题。 #include &lt;bits/stdc++.h&gt; #define int long long using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int mod = 998244353; int n, m, t; int x1, Y1, x2, y2; int v00, v01, v10, v11; int f[2][2]; /**/ signed main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; cin &gt;&gt; x1 &gt;&gt; Y1 &gt;&gt; x2 &gt;&gt; y2; f[0][0] = 1; while(t--) { v00 = (f[1][0] * (n - 1) % mod + f[0][1] * (m - 1) % mod) % mod; v01 = (f[0][1] * (m - 2) % mod + f[1][1] * (n - 1) % mod + f[0][0]) % mod; v10 = (f[1][0] * (n - 2) % mod + f[1][1] * (m - 1) % mod + f[0][0]) % mod; v11 = (f[1][1] * (n + m - 4) % mod + f[0][1] + f[1][0]) % mod; f[0][0] = v00, f[0][1] = v01, f[1][0] = v10, f[1][1] = v11; } cin &gt;&gt; x1 &gt;&gt; Y1 &gt;&gt; x2 &gt;&gt; y2; if(x1 == x2 &amp;&amp; Y1 == y2) cout &lt;&lt; f[0][0]; else if(x1 == x2 &amp;&amp; Y1 != y2) cout &lt;&lt; f[0][1]; else if(x1 != x2 &amp;&amp; Y1 == y2) cout &lt;&lt; f[1][0]; else cout &lt;&lt; f[1][1]; return 0; } ","link":"https://gujinli.github.io/post/abc232e-dpxian-xing-zhuang-tai-you-hua/"},{"title":"cf1620D 构造/1900","content":"D - Exact Change 题意： n个价值为ai的物品。有1、2、3三种硬币，能表示出每个ai的价格最少需要多少枚硬币 Solution： 首先1和2的个数都不可能超过3个，因为3个的话显然用面额3表示价格更大。因此枚举使用的1和2的数量，再判断3的数量即可。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 105; int t, n, a[N], ans; /**/ int main() { read(t); while(t--) { read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); ans = 0x7f7f7f7f; for(int one = 0; one &lt;= 2; one++) { for(int two = 0; two &lt;= 2; two++) { int three = 0; for(int i = 1; i &lt;= n; i++) { int minnum = 0x7f7f7f7f; for(int use1 = 0; use1 &lt;= one; use1++) { for(int use2 = 0; use2 &lt;= two; use2++) { int res = a[i] - use1 - use2 * 2; if(res &gt;= 0 &amp;&amp; res % 3 == 0) { minnum = min(minnum, res / 3); } } } three = max(three, minnum); } ans = min(ans, three + one + two); } } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0; } ","link":"https://gujinli.github.io/post/cf1620d-gou-zao-1900/"},{"title":"cf1619F 构造/2000","content":"F - Let's Play the Hat? 题意： n个人m张桌子玩k次游戏。每个人必须玩k次游戏。每个桌子的人数都是 n/m （上取整 或 下取整）。 定义 bib_ibi​ 为第iii 个人在人数为 n/m(上取整) 的桌子上玩的游戏次数。对任意 $ i, j $ 满足 ∣bi−bj∣&lt;=1|b_i - b_j| &lt;= 1∣bi​−bj​∣&lt;=1 Solution： 首先，m张桌子分给n个人，显然每张桌子的人数是确定的—— 大桌为n%m个，小桌为 m - n%m个。（每张桌子先坐 n/m（下取整）个人，剩下的 n%m 个人随便挑一个坐） 我们要使每个人在大桌上坐的次数相差不超过1。策略是这样的： 每次让坐在大桌上次数较少的人坐大桌，坐不满从较多的人补。这样显然可以保证相差不超过1。 实现的话可以考虑利用vector的rotate来滚动选择的人，每次坐大桌的人都让其移动到整个序列的最后排队。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } const int N = 2e5 + 5; int t, n, m, k; int main() { read(t); while(t--) { read(n); read(m); read(k); vector&lt;int&gt;v(n); for(int i = 0; i &lt; n; i++) v[i] = i + 1; int bt = n % m, bn = ceil(1.0 * n / m), sn = n / m; for(int i = 1; i &lt;= k; i++) { int pos = 0; for(int j = 1, num; j &lt;= m; j++) { if(j &lt;= bt) num = bn; else num = sn; cout &lt;&lt; num &lt;&lt; ' '; while(num--) cout &lt;&lt; v[pos++] &lt;&lt; ' '; puts(&quot;&quot;); } rotate(v.begin(), v.begin() + bn * bt, v.end()); } puts(&quot;&quot;); } return 0; } ","link":"https://gujinli.github.io/post/cf1619f-gou-zao-2000/"},{"title":"cf1619D 鸽巢原理/贪心/1800","content":"D - New Year's Problem 题意： n个人。m个商店。 每个商店有对应n个人的n个礼物，每个礼物有一个满意度ai,ja_{i,j}ai,j​ ，选择 n−1n-1n−1 个商店使得：所有人能/获得的最大满意度的最小值最大。 Solution： 定义lie[i]lie[i]lie[i] 表示第iii 个人的最大满意度。 显然，n个人选择n个商店的话，只需要把n个人最大满意度所在的商店选择即可。 根据鸽巢原理，n个人选择n-1的话，必然有两列的最优值在同一行。 我们枚举商店，选择一个商店记录其最大和次大，除去这两个人后，剩下的全部选择最大值即可。 复杂度O(nm)O(nm)O(nm) #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } const int N = 1e5 + 5; int t, n, m, ans, lie[N], pos1, pos2; int main() { read(t); while(t--) { read(m); read(n); ans = 0; vector&lt;int&gt;v[m+2]; for(int i = 1; i &lt;= m; i++) { v[i].push_back(0); for(int j = 1, x; j &lt;= n; j++) { lie[j] = 0; read(x); v[i].push_back(x); } } for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { lie[i] = max(lie[i], v[j][i]); } } for(int i = 1; i &lt;= m; i++) { pos1 = pos2 = 0; for(int j = 1; j &lt;= n; j++) { if(v[i][j] &gt; v[i][pos1]) pos2 = pos1, pos1 = j; else if(v[i][j] &gt; v[i][pos2]) pos2 = j; } int maxnum = min(v[i][pos1], v[i][pos2]); for(int j = 1; j &lt;= n; j++) { if(j == pos1 || j == pos2) continue; maxnum = min(maxnum, lie[j]); } ans = max(ans, maxnum); } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0; } ","link":"https://gujinli.github.io/post/cf1619d-ge-chao-yuan-li-tan-xin-1800/"},{"title":"cf1615E 博弈/构造/树/2400","content":"E - Purple Crayon 一个初始全部为空白节点的树。红（先手）蓝两方轮流对其染色：（注：以下操作可以进行任意次） 红：选择一个空白子树将其全部染为红色。（注：一回合染色的节点数不能超过k） 蓝：选择任意个空白子树将其全部染为蓝色。（染色数无限制） 定义val = w(r-b) ，w：空白节点，r：红色，b：蓝色。 红方想让val最大化，蓝方想让b最小化。求双方均采取最优策略的情况下的val。 val=(n−r−b)(r−b)=r(n−r)−b(n−b)val = (n-r-b)(r-b) = r(n-r)-b(n-b)val=(n−r−b)(r−b)=r(n−r)−b(n−b) 首先对于蓝方来说，只需要最大化b(n-b) ，即选尽可能多的节点。 红方先选： k &gt;= 叶 把所有叶节点全选了使得b=0。此时 val = r(n-r)。显然r接近2/n时最小。即r=max(min(2/n,k),叶)r = max(min(2/n, k),叶)r=max(min(2/n,k),叶) k &lt; 叶 即此时红方没有办法保证蓝方无点可选，显然选择一个叶节点后可以叶 -&gt; 根上的所有路径全部被染色。因此问题变成了求选k个点尽可能多的染色。根据官方题解的做法，我们可以先求出每个点的深度，降序排序后dfs。到达根或一个已染色的节点后返回这条链的长度。将链长降序排序后选择最大的k个即可。 之后剩下的就只能由蓝方任意选择了，如果剩下的所有点&lt;=2/n则全选，如果 &gt; 2/n ，则只需选 2/n个即可。因为b = 2/n时使得结果最小化，且r再选只会使结果更小。（因为已经是负值了） 关于求这样的链长除了染色以外，从dmyls那里学习的另一种做法如下： mx[u] 表示 u 到最底端的链长。每次遍历到u时，将所有的mx[v]存进一个vector中，最大的作为u的链继续向上延伸，其余的加入最后统计的链长里即可。 非常妙www，虽然会因为排序操作使时间复杂度变大，但毫无影响。 #include &lt;bits/stdc++.h&gt; #define ll long long #define mp make_pair #define fi first #define se second #define pb push_back #define vi vector&lt;int&gt; #define pi pair&lt;int, int&gt; #define mod 998244353 template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;} template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;} ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;} using namespace std; const int maxn = 200005; /**/ int n, k, mx[maxn], r, b; vi eg[maxn]; vi cur; /**/ void dfs(int u, int fa) { if(eg[u].size() == 1 &amp;&amp; fa) { mx[u] = 1; return; } vi cr; for(auto v : eg[u]) { if(v == fa) continue; dfs(v, u); cr.pb(mx[v]); } sort(cr.begin(), cr.end()); mx[u] = cr[cr.size() - 1] + 1; for(int i = 0; i &lt; cr.size() - 1; i++) cur.pb(cr[i]); } int main() { // freopen(&quot;test.in&quot;, &quot;r&quot;, stdin); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt; n; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); eg[u].pb(v), eg[v].pb(u); } // puts(&quot;ok1&quot;); dfs(1, 0); cur.pb(mx[1]); sort(cur.begin(), cur.end()); reverse(cur.begin(), cur.end()); if(k &gt; cur.size()) { b = 0; r = min(k, n / 2); if(r &lt; cur.size()) r = cur.size(); } else { r = k; b = n; for(int i = 0; i &lt; k; i++) b -= cur[i]; if(b &gt; n / 2) b = n / 2; } ll ans = 1ll * (n - r - b) * (r - b); cout &lt;&lt; ans &lt;&lt; '\\n'; return 0; } ","link":"https://gujinli.github.io/post/cf1615e-bo-yi-gou-zao-shu-2400/"},{"title":"cf1615D 树/异或/2200","content":"D - X(or)-mas Tree 给定一个树，边权为-1表示未知。给定m个节点间路径异或和二进制1个数的奇偶性，判断能否构造一个合法的树满足条件 一个性质：设两个数为x,y。二进制下x有a个1，y有b个1。则： a ^ b = num_1(x ^ y) % 2 所以对于每个边权，我们只需要考虑其1的个数的奇偶性。把m条边加上后一起遍历判断，不确定的边利用异或的性质输出边权即可 注意这里用了内置的位运算函数，简单介绍一下 __builtin_ffs (unsigned int x)返回x的最后一位1的是从后向前第几位，比如7368（1110011001000）返回4 __builtin_clz (unsigned int x)返回前导的0的个数。 __builtin_ctz (unsigned int x) 返回后面的0个个数，和; builtin_clz相对。 __ builtin_popcount (unsigned int x) 返回二进制表示中1的个数。 __builtin_parity (unsigned int x) 返回x的奇偶校验位，也就是x的1的个数模2的结果。 #include &lt;bits/stdc++.h&gt; #define ll long long #define mp make_pair #define fi first #define se second #define pb push_back #define vi vector&lt;int&gt; #define pi pair&lt;int, int&gt; #define fr(a) freopen(a, &quot;r&quot;, stdin) #define fo(a) freopen(a, &quot;w&quot;, stdout); #define mod 998244353 template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;} template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;} ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;} using namespace std; const int maxn = 200005; /**/ int t, n, m, err; int dis[maxn], vis[maxn]; vector&lt;pi&gt;g[maxn]; /**/ void dfs(int u) { if(err) return; for(auto i:g[u]) { int v = i.fi, w = i.se; if(dis[v] == -1) { dis[v] = dis[u] ^ w; dfs(v); } else if(dis[v] != (dis[u] ^ w)) { err = 1; return; } } } void solve() { err = 0; vector&lt; array&lt;int, 3&gt; &gt;ed; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { g[i].clear(); dis[i] = -1; } for(int i = 1; i &lt; n; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; ed.pb({u, v, w}); if(w == -1) continue; w = __builtin_parity(w); g[u].pb({v, w}); g[v].pb({u, w}); } for(int i = 1; i &lt;= m; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].pb({v, w}); g[v].pb({u, w}); } for(int i = 1; i &lt;= n; i++) { if(dis[i] == -1) dis[i] = 0, dfs(i); } if(err) {puts(&quot;NO&quot;); return;} puts(&quot;YES&quot;); for(auto i: ed) { int u = i[0], v = i[1], w = i[2]; if(w == -1) w = dis[u] ^ dis[v]; printf(&quot;%d %d %d\\n&quot;, u, v, w); } } int main() { // fr(&quot;test.in&quot;); // fo(&quot;test.out&quot;); ios::sync_with_stdio(0);cin.tie(0); int T; cin &gt;&gt; T; while(T--) { solve(); } return 0; } ","link":"https://gujinli.github.io/post/cf1615d-shu-yi-huo-2200/"},{"title":"cf1615C 贪心/数学/1600","content":"C - Menorah 两个01串s1和s2。求最少的操作数把s1变为s2，不能则为-1 操作：固定一个1，其余位全部取反 我们的目标是让所有的位置变得相同。 考虑两个字符串相同的0**(00)和1(11)的数量，以及不同的0(01)和1(10)**的数量。 一个位置点两次是没有意义的，而连续点两个位置相当于交换了两个位置。（1和0） 所以对于当前不同的，即01，10：我们有两种策略： 点不同的位置。如果不同的位置的1和0数量相等，即可全部交换。因为点了偶数次所以对初始相等的不造成影响 点相同的位置。相同的位置点奇数次，即可让不同的位置变成相同，那么问题转换成了如何点奇数次使得相同的位置不变。 我们只需要让1的数量比0的数量多1，即可在偶数次交换01后使有一个11，而其他的全部不同。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5; int t, n, sc1, sc0, dc1, dc0; char s1[N], s2[N]; /**/ int main() { read(t); while(t--) { read(n); scanf(&quot;%s%s&quot;, s1 + 1, s2 + 1); sc1 = sc0 = dc1 = dc0 = 0; for(int i = 1; i &lt;= n; i++) { if(s1[i] == s2[i]) { if(s1[i] == '1') sc1++; else sc0++; } else { if(s1[i] == '1') dc1++; else dc0++; } } int ans = 0x3f3f3f3f; if(dc0 == dc1) ans = min(ans, dc0 + dc1); if(sc1 == sc0 + 1) ans = min(ans, sc1 + sc0); if(ans == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; '\\n'; else cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0; } ","link":"https://gujinli.github.io/post/cf1615c-tan-xin-shu-xue-1600/"},{"title":"cf1591D 逆序对/1900","content":" D - Yet Another Sorting Problem 一段长度为n的序列。每次可以选择一个三元组 (i,j,k)(i, j, k)(i,j,k)，然后将 ai,aj,aka_i, a_j,a_kai​,aj​,ak​ 三个数环形交换。即：aj=ai,ak=aj,ai=aka_j=a_i,a_k=a_j,a_i=a_kaj​=ai​,ak​=aj​,ai​=ak​ 判断是否通过这样的操作（次数不限）使得序列有序 当(ai,aj,ak)(a_i,a_j,a_k)(ai​,aj​,ak​)三个数两两不相等时，我们发现，无论执行多少次这样的操作，逆序数只会改变0或2。 当(ai,aj,ak)(a_i,a_j,a_k)(ai​,aj​,ak​)存在两个数相等时，逆序数可以改变1（也可以改变2）。 因此我们这样判断：如果逆序数%2==0，说明可以使逆序数变为0，即单调非降。 特别的，如果存在两个数相等，那么奇偶性就可以任意改变，故也可以使序列有序。 其余情况为NO。 #include &lt;bits/stdc++.h&gt; #define int long long using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(); while(c&gt;'9'||c&lt;'0') c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar(); } const int N=5e5+5; int n,c[N],rk[N], t; int ans; struct node { int id,w; bool operator &lt; (const node &amp;b) const { return w==b.w?id&lt;b.id:w&lt;b.w; } }a[N]; inline void insert(int x,int w) { for(;x&lt;=n;x+=x&amp;-x) c[x]+=w; } inline int query(int x) { int sum=0; for(;x;x-=x&amp;-x) sum+=c[x]; return sum; } signed main() { read(t); while(t--) { ans = 0; read(n); for(int i=1;i&lt;=n;i++) read(a[i].w),a[i].id=i; sort(a+1,a+1+n); bool flag = 0; for(int i = 2; i &lt;= n; i++) { if(a[i].w == a[i - 1].w) {flag = 1; break;} } if(flag) {puts(&quot;YES&quot;); continue;} for(int i=1;i&lt;=n;i++) rk[a[i].id]=i; for(int i=1;i&lt;=n;i++) { insert(rk[i],1); ans += i - query(rk[i]); } if(ans &amp; 1) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); for(int i = 0; i &lt;= n; i++) c[i] = rk[i] = 0; } return 0; } ","link":"https://gujinli.github.io/post/cf1591d-ni-xu-dui-1900/"},{"title":"漫漫ACM之路","content":"图论： **生成树问题： ** 最小生成树 次小生成树(非严格/严格) 瓶颈生成树 kruscal重构树 最小树形图 最小直径生成树 树上问题: 基础性质 (直径,重心) 最近公共祖先(LCA) 树上启发式合并(dsu on tree) 虚树 树链剖分 重链剖分 长链剖分 树分治: 点分治 边分治 点分树 动态树分治 树同构: AHU 树哈希 最短路问题： Johnson 全源最短路径算法 分层图最短路 k短路 同余最短路 差分约束 连通问题: 强连通分量 双连通分量 割点和桥 圆方树 2-SAT 特殊图问题: 欧拉图 哈密顿图 二分图 图的着色 平面图 特殊应用: 斯坦纳树 矩阵树定理 ","link":"https://gujinli.github.io/post/man-man-acm-zhi-lu/"},{"title":"杂记","content":"bitset bitset是像bool数组一样的东西。但每个位置只占1bit。 一定程度上节省了空间和时间，一般来说会让算法复杂度/32。 定义与初始化： 头文件：#include&lt;bitset&gt; 定义时需指明所占用的空间（类数组）：bitset&lt;114514&gt;bit; 初始化可以用string或int（整数类型）： bitset&lt;23&gt;bit (string(&quot;11101001&quot;)); bitset&lt;23&gt;bit = 233; 常用函数： bit.size() 返回大小（位数） bit.count() 返回1的个数 bit.any() 返回是否有1 bit.none() 返回是否没有1 bit.set() 全都变成1 bit.set(p) 将第p + 1位变成1（bitset是从第0位开始的！） bit.set(p, x) 将第p + 1位变成x bit.reset() 全都变成0 bit.reset(p) 将第p + 1位变成0 bit.flip() 全都取反 bit.flip(p) 将第p + 1位取反 bit.to_ulong() 返回它转换为unsigned long的结果，如果超出范围则报错 bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错 bit.to_string() 返回它转换为string的结果 杂stl rotate ：用于vector rotate(a, b, c) 把 b ~ c 的元素放到 a 前面。 把[a ~ b) 和 [b, c) 互换 高效位运算 __builtin_ffs (unsigned int x)返回x的最后一位1的是从后向前第几位，比如7368（1110011001000）返回4 __builtin_clz (unsigned int x)返回前导的0的个数。 __builtin_ctz (unsigned int x) 返回后面的0个个数，和; builtin_clz相对。 __ builtin_popcount (unsigned int x) 返回二进制表示中1的个数。 __builtin_parity (unsigned int x) 返回x的奇偶校验位，也就是x的1的个数模2的结果。 ","link":"https://gujinli.github.io/post/za-ji/"},{"title":"ICPC2021沈阳 部分题解","content":"E. Edward Gaming, the Champion(签到题) 题意： 求一个字符串s中有多少个&quot;edgnb&quot; Solution： EDGNBEDGNBEDGNB #include &lt;bits/stdc++.h&gt; using namespace std; /**/ const int N = 2e5 + 5; char s[N]; /**/ int main() { scanf(&quot;%s&quot;, s); int len = strlen(s), ans = 0; for(int i = 0; i &lt; len; i++) { if(i+4&gt;=len) break; if(s[i]=='e'&amp;&amp;s[i+1]=='d'&amp;&amp;s[i+2]=='g'&amp;&amp;s[i+3]=='n'&amp;&amp;s[i+4]=='b') ans++, i = i + 4; } cout&lt;&lt;ans; return 0; } F. Encoded Strings I（签到题/模拟） 题意： 队友A的，待补。 Solution： 队友A的，待补。 #include &lt;bits/stdc++.h&gt; #define il inline #define ll long long #define Max 1005 #define int ll using namespace std; il ll read() { char c=getchar(); ll x=0,f=1; while(c&gt;'9'||c&lt;'0') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { x=x*10+c-'0'; c=getchar(); } return x*f; } int n,a[Max],c[Max],id[Max]; char s[Max],t[Max][Max]; il bool cmp(int x,int y) { int l=min(strlen(t[x]+1),strlen(t[y]+1)); for(int i=1;i&lt;=l;i++) { if(t[x][i]&lt;t[y][i]) return 0; if(t[x][i]&gt;t[y][i]) return 1; } return strlen(t[x]+1)&gt;strlen(t[y]+1); } signed main() { n=read(); scanf(&quot;%s&quot;,s+1); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=26;j++) c[j]=0; int tot=0; for(int j=i;j&gt;=1;j--) { if(!c[s[j]-'a'+1]) t[i][j]=tot+'a',c[s[j]-'a'+1]=++tot; else t[i][j]=c[s[j]-'a'+1]+'a'-1; //cout&lt;&lt;j&lt;&lt;' '&lt;&lt;c[s[j]-'a'+1]&lt;&lt;' '&lt;&lt;s[j]&lt;&lt;' '&lt;&lt;tot&lt;&lt;&quot; qwq\\n&quot;; } } //for(int i=1;i&lt;=n;i++) puts(t[i]+1); for(int i=1;i&lt;=n;i++) id[i]=i; sort(id+1,id+1+n,cmp); puts(t[id[1]]+1); } J. Luggage Lock（bfs） 题意： 一个四位数密码。给定起始状态 A 和终止状态 B 。每次可以选择一段区间向上拧或向下拧（即+1/−1+1/-1+1/−1）。 求由A变为B的最小操作次数。 Solution： 因为所有的两组状态都可以转化成 起始状态为 0000。因此对于 0000 开始，其实只有 10000 种状态。 预处理：利用 bfs 求最少步数。同时对已经得到的状态进行标记即可。 然后即可对每组询问 O(1) 输出。 #include &lt;bits/stdc++.h&gt; #define PII pair&lt;string,int&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const string opt[15] = {&quot;0001&quot;,&quot;0011&quot;,&quot;0111&quot;,&quot;1111&quot;,&quot;0010&quot;,&quot;0110&quot;,&quot;1110&quot;,&quot;0100&quot;,&quot;1100&quot;,&quot;1000&quot;}; int vis[10005], ans[10005]; /**/ inline int get(string s) { int ret = 0; for(int i=0;i&lt;4;i++) ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+s[i]-'0'; return ret; } inline string work(string s,int p,int flag) { string ret = s; for(int i=0;i&lt;4;i++) { if(opt[p][i]=='0') continue; ret[i]=(ret[i]-'0'+flag+10)%10+'0'; } return ret; } int main() { queue&lt;PII&gt;q; q.push(PII(&quot;0000&quot;,0)); vis[0] = 1; while(!q.empty()) { PII t = q.front(); q.pop(); string u = t.first; int step = t.second; for (int i = 0; i &lt; 10; i++) { string s1 = work(u,i,1); string s2 = work(u,i,-1); int num1 = get(s1), num2 = get(s2); if(!vis[num1]) { vis[num1]=1; ans[num1]=step + 1; q.push(PII(s1, step + 1)); } if(!vis[num2]) vis[num2] = 1, ans[num2] = step + 1, q.push(PII(s2, step + 1)); } } int t; read(t); string S1, S2, T; while(t--) { cin &gt;&gt; S1 &gt;&gt; S2; int ret = 0; for(int i=0;i&lt;4;i++) { ret = ret * 10 + (S2[i]-S1[i]+10)%10; } cout &lt;&lt; ans[ret] &lt;&lt; '\\n'; } return 0; } B. Bitwise Exclusive-OR Sequence（铜牌题） 题意： 一段长度为 nnn 的数。给定 mmm 组关系。每组关系 (u,v,w)(u,v,w)(u,v,w) 描述了：au⊕av=wa_u \\oplus a_v=wau​⊕av​=w 求这组数 各元素和 的最小值。 Solution： 可以根据每组关系建边，随意以一个有出边的点为树根进行遍历。 定义 dis[u]dis[u]dis[u] 为 从根节点到 uuu 的边权异或和。根据异或性质易知：art⊕au=disua_{rt} \\oplus a_u = dis_uart​⊕au​=disu​ 如果出现两个不同值的 dis[u]dis[u]dis[u] 则数据出现矛盾输出 -1。 对该森林的其中一个树，tot[i]tot[i]tot[i] 表示所有 dis[u]dis[u]dis[u] 的第 iii 位为1的数量。超过一半则让根该位为1更优，否则让根该位为0。 #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5, M = 4e5 + 5; int n, m, head[N], cnt, dis[N], tot[N], vis[N], sum; bool err; ll ans; struct edge { int nxt, to, w; }e[M]; /**/ inline void add(int u, int v, int w) { e[++cnt] = (edge){head[u], v, w}; head[u] = cnt; } void dfs(int u, int fa, int ti) { if(err) return; for(int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa) continue; if(vis[v]) { if((dis[u] ^ e[i].w) == dis[v]) continue; else {err = 1; return;} } vis[v] = ti; dis[v] = (dis[u] ^ e[i].w); sum++; for(int j = 0; j &lt;= 30; j++) { if(dis[v] &amp; (1&lt;&lt;j)) tot[j]++; } dfs(v, u, ti); if(err) return; } } int main() { read(n); read(m); for(int i = 1, u, v, w; i &lt;= m; i++) { read(u); read(v); read(w); if(u==v) { if(w) err = 1; continue; } add(u, v, w); add(v, u, w); } if(err) {puts(&quot;-1&quot;);return 0;} for(int i = 1; i &lt;= n; i++) { if(!head[i]) continue; if(vis[i]) continue; vis[i] = i; dfs(i, 0, i); sum++; for(int j = 0; j &lt;= 30; j++) { ans += 1ll * min(tot[j], sum - tot[j]) * (1 &lt;&lt; j); tot[j] = 0; } sum = 0; if(err) {puts(&quot;-1&quot;); return 0;} } if(err) {puts(&quot;-1&quot;); return 0;} cout &lt;&lt; ans &lt;&lt; '\\n'; return 0; } L. Perfect Matchings（树形dp+容斥） 题意： 队友A的，待补。 Solution： 队友A的，待补。 #include &lt;bits/stdc++.h&gt; #define il inline #define ll long long #define Max 4010 #define Mod 998244353 #define int ll using namespace std; il ll read() { char c=getchar(); ll x=0,f=1; while(c&gt;'9'||c&lt;'0') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { x=x*10+c-'0'; c=getchar(); } return x*f; } struct node { int t,nt; }e[Max&lt;&lt;1]; int n,head[Max],tot,f[Max][Max][2],g[Max],sz[Max],ans; il void add(int u,int v) { e[++tot].t=v; e[tot].nt=head[u]; head[u]=tot; } il void dfs(int u,int fa) { sz[u]=1; for(int i=head[u];i;i=e[i].nt) { int v=e[i].t; if(v==fa) continue; dfs(v,u); sz[u]+=sz[v]; } int s=1; //f[u][0][0]=1; f[u][0][0]=1; for(int i=head[u];i;i=e[i].nt) { int v=e[i].t; if(v==fa) continue; for(int j=s/2+1;j&gt;=0;j--) { for(int k=1;k&lt;=sz[v]/2+1;k++) { //if(j==0&amp;&amp;k==0) continue; f[u][j+k][0]=(f[u][j+k][0]+f[u][j][0]*f[v][k][0]+f[u][j][0]*f[v][k][1])%Mod; //f[u][0][0]=1; f[u][j+k][1]=(f[u][j+k][1]+f[u][j][0]*f[v][k-1][0]+f[u][j][1]*(f[v][k][0]+f[v][k][1]))%Mod; //cout&lt;&lt;u&lt;&lt;' '&lt;&lt;v&lt;&lt;' '&lt;&lt;j&lt;&lt;' '&lt;&lt;k&lt;&lt;' '&lt;&lt;f[1][1][1]&lt;&lt;&quot; qwq\\n&quot;; } } s+=sz[v]; } } signed main() { n=read()*2; for(int i=1;i&lt;n;i++) { int u=read(),v=read(); add(u,v),add(v,u); } g[0]=1; for(int i=2;i&lt;=n;i+=2) g[i]=(i-1)*g[i-2]%Mod; dfs(1,0); //for(int i=0;i&lt;=n/2;i++) cout&lt;&lt;f[1][i][1]&lt;&lt;' '&lt;&lt;f[1][i][0]&lt;&lt;endl; for(int i=0;i&lt;=n/2;i++) { ans=ans+(g[n-i*2]*(f[1][i][1]+f[1][i][0])%Mod*(i&amp;1?-1:1)+Mod); ans=(ans+Mod)%Mod; } cout&lt;&lt;ans&lt;&lt;endl; } M. String Problem（KMP） 题意： 给定一个长度为 nnn 的字符串s。输出 nnn 行 (li,ri)(l_i, r_i)(li​,ri​) 表示： 对 s 的前缀 s1...is_{1...i}s1...i​ 中字典序最大的子串。 Solution： 首先容易得到 ri=ir_i = iri​=i。然后做了一个神奇的 KMP 。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e6 + 5; char s[N]; int nxt[N]; int main() { scanf(&quot;%s&quot;, s + 1); int len = strlen(s + 1); puts(&quot;1 1&quot;); int pos = 1, j = 1; for(int i = 2; i &lt;= len; i++) { while(j &amp;&amp; s[i] &gt; s[pos + nxt[j]]) { pos += (j - nxt[j]); j = nxt[j]; } if(j &amp;&amp; s[i] == s[pos + nxt[j]]) { j++; nxt[j] = nxt[j - 1] + 1; } else nxt[++j] = 0; printf(&quot;%d %d\\n&quot;, pos, i); } return 0; } ","link":"https://gujinli.github.io/post/icpc2021-shen-yang-bu-fen-ti-jie/"},{"title":"ICPC2021上海 部分题解","content":" 场外一共做了六道题，罚时大概是银末的位置、场上的话估计只能铜。 题目质量还是挺高的很有意思。 E Strange Integers（签到题） 题意： 一段长度为n的序列。从中选出尽可能多的数，使任意两个数之间的绝对值相差大于k。 Solution： 对序列排序后从小到大。最小的数一定选，之后的从小到大能选就选。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5; int n, k, a[N], ans, rec; /**/ int main() { read(n); read(k); for(int i = 1; i &lt;= n; i++) read(a[i]); sort(a + 1, a + 1 + n); rec = -1000000000; for(int i = 1; i &lt;= n; i++) { // cout &lt;&lt; if(a[i] - rec &gt;= k) rec = a[i], ans++; } cout &lt;&lt; ans &lt;&lt; '\\n'; return 0; } D Strange Fractions（签到题） 题意： 给定p和q。求一组合法的a和b满足： pq=ab+ba\\frac{p}{q} = \\frac{a}{b} + \\frac{b}{a} qp​=ba​+ab​ Solution： 先推式子： pq=a2+b2abp+2qq=(a+b)2ab(p+2q)2q(p+2q)=(a+b)2ab\\frac{p}{q} = \\frac{a^2+b^2}{ab}\\\\ \\frac{p+2q}{q} = \\frac{(a+b)^2}{ab}\\\\ \\frac{(p+2q)^2}{q(p+2q)} = \\frac{(a+b)^2}{ab}\\\\ qp​=aba2+b2​qp+2q​=ab(a+b)2​q(p+2q)(p+2q)2​=ab(a+b)2​ 得 a+b=p+2qab=q(p+2q)a + b = p + 2q\\quad{}ab = q(p + 2q)a+b=p+2qab=q(p+2q) 联立即可得到 aaa 和 bbb 。同除以 gcdgcdgcd 约分一下即可。 注： p+2qp + 2qp+2q 是完全平方数则有解， 否则无解。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ int t, p, q, num1, num2, num3, num4, a, b, g; /**/ signed main() { read(t); while(t--) { read(p); read(q); num1 = p + 2 * q;// a + b num2 = num1 * q;// ab num3 = num1 * num1 - 4 * num2;// (a - b) ^ 2 num4 = sqrt(num3);// a - b if(num4 * num4 != num3) puts(&quot;0 0&quot;); else { a = (num1 + num4) / 2; b = num1 - a; g = __gcd(a, b); a /= g; b /= g; cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\\n'; } } return 0; } G Edge Groups（树形dp） 题意： n（奇数）个点的树，n-1条边分成 n−12\\frac{n-1}{2}2n−1​组，每组两条边并且两条边要有一个公共点。求分组的方案数。 Solution： 首先。n个元素两两分组的方案数是 f[n]f[n]f[n] ，则有递推式 f[n]=f[n−2]∗(n−1)f[n] = f[n- 2] * (n - 1)f[n]=f[n−2]∗(n−1) 设dp[u]dp[u]dp[u]为uuu子树的方案数。bbb 表示uuu子树中点数为奇数的个数。 dp[u]={f[b]∗∏f[v] b is evenf[b+1]∗∏f[v]b is odddp[u] = \\begin{cases} f[b]*\\prod f[v] \\quad\\quad\\;\\; \\text{b is even} \\\\ f[b+1]*\\prod f[v] \\quad \\text{b is odd} \\end{cases} dp[u]={f[b]∗∏f[v]b is evenf[b+1]∗∏f[v]b is odd​ #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5, mod = 998244353; int n, sz[N]; ll f[N], dp[N]; vector&lt;int&gt;g[N]; /**/ void dfs(int u, int fa) { sz[u] = 1; dp[u] = 1; int cnt = 0; for(auto &amp;v : g[u]) { if(v == fa) continue; dfs(v, u); sz[u] += sz[v]; dp[u] = dp[u] * dp[v] % mod; if(sz[v] &amp; 1) cnt++; } if(cnt &amp; 1) cnt++; dp[u] = dp[u] * f[cnt] % mod; } signed main() { read(n); for(int i = 1, x, y; i &lt; n; i++) { read(x); read(y); g[x].push_back(y); g[y].push_back(x); } f[0] = 1; for(int i = 2; i &lt;= n; i += 2) { f[i] = f[i - 2] * (i - 1) % mod; } dfs(1, 0); cout &lt;&lt; dp[1]; return 0; } I Steadily Growing Steam（签到题/背包） 题意： n 个物品。每个物品有价值w[i] 和 体积 v[i]，求从中选出两个无交集的集合，两个集合的体积和相等，价值和最大。 注：可以将这n个物品中至多k个物品的体积翻倍。 Solution： 对选入两个集合分别用正负进行表示即可，注意边界问题的处理正常背包即可。 #include &lt;bits/stdc++.h&gt; using namespace std; #define ll long long inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ int n, k, w[105], v[105], m; ll f[105][3000][105], ans; /**/ int main() { read(n); read(k); ans = 0; for(int i = 1; i &lt;= n; i++) {read(w[i]); read(v[i]);} memset(f, -0x3f, sizeof(f)); f[0][1400][0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = 0; j &lt;= 2800; j++) { f[i][j][0] = max(max(f[i][j][0], f[i-1][j][0]), f[i-1][j+v[i]][0]+w[i]); if(j&gt;=v[i]) f[i][j][0] = max(f[i][j][0], f[i-1][j-v[i]][0]+w[i]); for(int t = 1; t &lt;= min(i, k); t++) { f[i][j][t] = max(max(f[i][j][t], f[i-1][j][t]), max(f[i-1][j+2*v[i]][t-1], f[i-1][j+v[i]][t])+w[i]); if(j&gt;=v[i]) f[i][j][t] = max(f[i][j][t], f[i-1][j-v[i]][t]+w[i]); if(j&gt;=2*v[i]) f[i][j][t] = max(f[i][j][t], f[i-1][j-2*v[i]][t-1]+w[i]); } } } for(int i = 0; i &lt;= k; i++) ans = max(ans, f[n][1400][i]); cout &lt;&lt; ans &lt;&lt; '\\n'; return 0; } K Circle of Life（银牌题/构造） 题意： 一个n位的由0和1组成的串。对每秒，1（星星）变成0向两边发射1，两个扩散的星星相撞则变成0。 Solution： 暴力打表找规律。找出某一循环的特殊性质后输出。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } inline void W(int x) {if(x&lt;0){putchar('-'),x=-x;}write(x);} /**/ int n; /**/ int main() { cin &gt;&gt; n; if(n == 3) {puts(&quot;Unlucky&quot;); return 0;} else { if(n&amp;1) printf(&quot;100&quot;),n-=3; n/=2; for(int i=1;i&lt;=n;i++) { if(i&amp;1) printf(&quot;01&quot;); else printf(&quot;10&quot;); } } return 0; } M Harmony in Harmony(银牌题/构造) 题意： 待补。 Solution： 瞎猜的。待补。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } int n,m; signed main() { read(n); for(int i=1;i&lt;=n;i++) { m=max(m,(n*(i)*(n-i+1))); } printf(&quot;%.9f&quot;,1.0/m); } H Life is a Game(铜牌题/kruscal重构树|可并堆) 题意： 对于n个点m条边的无向图有q个询问。图有点权和边权，每个询问 x,k 表示从 x 出发，初始能力值为k，当能力值大于边权则能通过这条边，第一次到达一个点可以获得该点点权的能力值。求可以获得的最大能力。 Solution： 对边按边权从小到大排序。询问离线，用n个堆维护每个点的询问（按k从小到大维护）。 枚举边，对边（无向）的两个端点，分别取出能力值不能通过这条边的询问，记录答案。 对于剩下的结点（全部能够通过这条边），利用并查集合并这两个节点，同时将堆按并查集的思路 启发式合并（小堆并大堆）。 枚举完边后对于剩余没有得到答案的询问（即合并完成的询问），单独取出并记录答案。 #include &lt;bits/stdc++.h&gt; #define PII pair&lt;int, int&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5; int n, m, t, sum[N], fa[N], ans[N]; struct edge { int from, to, w; bool operator &lt; (const edge &amp;b) const {return w &lt; b.w;} }e[N]; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt;q[N]; /**/ inline int find(int x){return x == fa[x] ? x : fa[x] = find(fa[x]);} int main() { read(n); read(m); read(t); for(int i = 1; i &lt;= n; i++) read(sum[i]), fa[i] = i; for(int i = 1, u, v, w; i &lt;= m; i++) read(u), read(v), read(w), e[i] = (edge){u, v, w}; sort(e + 1, e + 1 + m); for(int i = 1, x, k; i &lt;= t; i++) read(x), read(k), q[x].push(PII(k, i)); for(int i = 1; i &lt;= m; i++) { int u = find(e[i].from), v = find(e[i].to); if(u == v) continue; while(!q[u].empty() &amp;&amp; q[u].top().first + sum[u] &lt; e[i].w) { int id = q[u].top().second; ans[id] = q[u].top().first + sum[u]; q[u].pop(); } while(!q[v].empty() &amp;&amp; q[v].top().first + sum[v] &lt; e[i].w) { int id = q[v].top().second; ans[id] = q[v].top().first + sum[v]; q[v].pop(); } if(q[u].size() &gt; q[v].size()) swap(u, v); while(!q[u].empty()) q[v].push(q[u].top()), q[u].pop(); fa[u] = v; sum[v] += sum[u]; } for(int i = 1; i &lt;= n; i++) { int u = find(i); while(!q[u].empty()) { PII x = q[u].top(); q[u].pop(); ans[x.second] = x.first + sum[u]; } } for(int i = 1; i &lt;= t; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; return 0; } J Two Binary Strings Problem（银牌题/bitset） 题意： 给定长度为n的两个01串A和B。f(l,r)!f(l,r)!f(l,r)!表示区间lll到rrr的众数。（01数量相等时为0） 求一个长度同样为n的01串ansansans，anskans_kansk​为 1 时当且仅当：对所有1≤i≤n有f(max(i−k+1,1),i)=Bi1\\le i\\le n\\quad{有}f(max(i-k+1, 1), i) = B_i1≤i≤n有f(max(i−k+1,1),i)=Bi​ 成立 Solution： A 0 1 1 0 1 0 1K10 1 1 0 1 0 1K20 0 1 0 0 0 0K30 0 1 1 1 0 1K40 0 1 0 1 0 0K50 0 1 0 1 1 1K60 0 1 0 1 0 1K70 0 1 0 1 0 1A\\quad\\;\\; 0\\; 1\\; 1\\; 0\\; 1\\; 0\\; 1\\\\ K1\\quad 0\\; 1\\; 1\\; 0\\; 1\\; 0\\; 1\\\\ K2\\quad 0\\; 0\\; 1\\; 0\\; 0\\; 0\\; 0\\\\ K3\\quad 0\\; 0\\; 1\\; 1\\; 1\\; 0\\; 1\\\\ K4\\quad 0\\; 0\\; 1\\; 0\\; 1\\; 0\\; 0\\\\ K5\\quad 0\\; 0\\; 1\\; 0\\; 1\\; 1\\; 1\\\\ K6\\quad 0\\; 0\\; 1\\; 0\\; 1\\; 0\\; 1\\\\ K7\\quad 0\\; 0\\; 1\\; 0\\; 1\\; 0\\; 1\\\\ A0110101K10110101K20010000K30011101K40010100K50010111K60010101K70010101 对于每一行，若Ci=BC_i = BCi​=B ，则 ansi=1ans_i = 1ansi​=1 由于行之间的关系不好找，转成列 。 对于第i列，找到最近的 jjj使 j+1...ij+1...ij+1...i 的0和1相等。因为是最近的，故f(j+1,i)=0,而f(j+k,i)=Ai(1≤k≤i−j)故f(j+1,i)=0, 而f(j+k,i)=A_i (1\\le k \\le i-j)故f(j+1,i)=0,而f(j+k,i)=Ai​(1≤k≤i−j) 故对于CiC_iCi​的1...(i−j−1)1...(i-j-1)1...(i−j−1)项均=Ai=A_i=Ai​，第i−ji-ji−j项恰好=0=0=0。第(i−j+1)...n(i-j+1)...n(i−j+1)...n可由CjC_jCj​转移。 若找不到jjj，则CiC_iCi​全部等于AiA_iAi​。 难点其实在位运算的转移上。需要思考一下。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 5e4 + 5; int t, n, tot[N*2]; char A[N], B[N]; bitset&lt;N&gt;C[N], ans, all1; /**/ int main() { read(t); while(t--) { read(n); scanf(&quot;%s%s&quot;, A, B); for(int i = 0; i &lt; n; i++) all1[i] = 1, C[i] = 0; ans = all1; for(int i = 0; i &lt;= 2*n; i++) tot[i] = -2; tot[n] = -1; int rec = n; for(int i = 0; i &lt; n; i++) { A[i] == '1' ? ++rec : --rec; int j = tot[rec]; // printf(&quot;i = %d, j = %d\\n&quot;, i + 1, j); if(j == -2) A[i] == '1' ? C[i] = all1 : C[i] = 0; else { //1 -&gt; (i - j - 1) 位 = A[i] , 第 i - j 位 = 0 ( 0和1 恰好 相等) , 剩下的由之前的递推而来 if(A[i] == '1') C[i] |= all1 &gt;&gt; (n - (i - j - 1) ); //原来n位，变成(i-j-1)位 if(j != -1) C[i] |= C[j] &lt;&lt; (i - j); else if(C[i][i]) C[i] |= all1 &lt;&lt; i; // K &gt; (i - j); } // for(int k = 0; k &lt; n; k++) cout &lt;&lt; C[i][k]; puts(&quot;&quot;); tot[rec] = i; ans &amp;= (B[i]=='1' ? C[i] : ~C[i]); } for(int i = 0; i &lt; n; i++) cout &lt;&lt; ans[i]; putchar('\\n'); } return 0; } ","link":"https://gujinli.github.io/post/icpc2021-shang-hai-bu-fen-ti-jie/"}]}