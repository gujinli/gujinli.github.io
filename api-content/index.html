{"posts":[{"title":"codechef LTIME103B 赛后题解","content":"比赛链接 A. Optimal Sorting 选择一段连续区间sort的代价是这段区间的最大值-最小值。求把整个数列sort的最小代价 一整段区间分开sort更优 当且仅当 后面所有数的最小值 &gt; 当前最大值。即产生了一段空隙 因为当前最大值如果大于后面所有数的最小值的话，必然要合并在一起sort。 维护后缀最小值从前向后枚举即可。复杂度 O(n) #include &lt;bits/stdc++.h&gt; #define ll long long #define mp make_pair #define fi first #define se second #define pb push_back #define vi vector&lt;int&gt; #define pi pair&lt;int, int&gt; #define fr(a) freopen(a, &quot;r&quot;, stdin) #define fo(a) freopen(a, &quot;w&quot;, stdout); #define mod 998244353 template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;} template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;} ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;} using namespace std; const int maxn = 200005; /**/ int t, n, a[maxn], mi[maxn]; /**/ int main() { // fr(&quot;test.in&quot;); ios::sync_with_stdio(0);cin.tie(0); cin &gt;&gt; t; while(t--) { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } mi[n] = a[n]; for(int i = n - 1; i &gt;= 1; i--) { mi[i] = min(mi[i + 1], a[i]); } int ans = 0, maxnum = 0, minnum = 0x3f3f3f3f; mi[n + 1] = INT_MAX; for(int i = 1; i &lt;= n; i++) { maxnum = max(maxnum, a[i]); minnum = min(minnum, a[i]); if(mi[i + 1] &gt; maxnum) { ans += maxnum - minnum; maxnum = 0; minnum = 0x3f3f3f3f; } } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0; } B.Sleep Technique ","link":"https://gujinli.github.io/post/codechef-ltime103b-sai-hou-ti-jie/"},{"title":"codechef INFI21B 赛后题解","content":"比赛链接 B. Dalgona Treat 题意： 求n个平方数相加得到一个完全平方数，数的种类不能超过10 Solution： n2=(n−2)2∗1+22∗(n−1)n^2=(n-2)^2*1+2^2*(n-1)n2=(n−2)2∗1+22∗(n−1)。 小于3的情况特判直接输出。注意n=4n=4n=4的时候，有n−2=2n-2=2n−2=2，同样特判处理 #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; int t; int n; int main() { cin &gt;&gt; t; while(t--) { cin &gt;&gt; n; if(n == 1) puts(&quot;1\\n1 1&quot;); else if(n == 2) puts(&quot;2\\n3 1\\n4 1&quot;); else if(n == 4) puts(&quot;1\\n1 4&quot;); else { printf(&quot;2\\n2 %d\\n&quot;, n - 1); printf(&quot;%d 1\\n&quot;, n - 2); } } return 0; } C. Tug of War 题意： A队有n人，B队有m人，给定了每个人的能力值ai和bi。A队按照(a1...n)的顺序出场，获胜的人留在场上，输了的人离场，平局都立场。求B队能否获胜，如果能的话，输出字典序最小的排列。 Solution： 将B队降序排列。令p1表示A当前的人，p2表示B当前的人。用双指针找出B获胜需要的人，将剩余的人升序输出，获胜需要的人降序输出即可。 证明见官方题解： #include &lt;bits/stdc++.h&gt; #define ll long long // #define int ll #define mp make_pair #define fi first #define se second #define pb push_back #define vi vector&lt;int&gt; #define pi pair&lt;int, int&gt; #define vpii vector&lt;pi&gt; #define il inline #define ri register #define all(a) a.begin(), a.end() #define fr(a) freopen(a, &quot;r&quot;, stdin) #define fo(a) freopen(a, &quot;w&quot;, stdout); #define mod 998244353 template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;} template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;} ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;} using namespace std; const int maxn = 1000005; /**/ int n, m, a[maxn], b[maxn]; /**/ il bool cmp(int x, int y) { return x &gt; y;} il void solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;b[i]); sort(b + 1, b + 1 + m, cmp); int p1 = 1, p2 = 1, err = 0; while(p1 &lt;= n &amp;&amp; p2 &lt;= m) { if(a[p1] &gt; b[p2]) { err = 1; break; } else if(a[p1] &lt; b[p2]) { ++p1; else ++p1, ++p2; } if(p2 &gt; m || err) {printf(&quot;NO\\n&quot;); return;} printf(&quot;YES\\n&quot;); for(int i = m; i &gt; p2; i--) cout &lt;&lt; b[i] &lt;&lt; ' '; for(int i = 1; i &lt;= p2; i++) cout &lt;&lt; b[i] &lt;&lt; ' '; puts(&quot;&quot;); } signed main() { int T; cin &gt;&gt; T; while(T--) { solve(); } return 0; } ","link":"https://gujinli.github.io/post/codechef-infi21b-sai-hou-ti-jie/"},{"title":"CF 1591 div2 赛后题解","content":" D - Yet Another Sorting Problem 一段长度为n的序列。每次可以选择一个三元组 (i,j,k)(i, j, k)(i,j,k)，然后将 ai,aj,aka_i, a_j,a_kai​,aj​,ak​ 三个数环形交换。即：aj=ai,ak=aj,ai=aka_j=a_i,a_k=a_j,a_i=a_kaj​=ai​,ak​=aj​,ai​=ak​ 判断是否通过这样的操作（次数不限）使得序列有序 当(ai,aj,ak)(a_i,a_j,a_k)(ai​,aj​,ak​)三个数两两不相等时，我们发现，无论执行多少次这样的操作，逆序数只会改变0或2。 当(ai,aj,ak)(a_i,a_j,a_k)(ai​,aj​,ak​)存在两个数相等时，逆序数可以改变1（也可以改变2）。 因此我们这样判断：如果逆序数%2==0，说明可以使逆序数变为0，即单调非降。 特别的，如果存在两个数相等，那么奇偶性就可以任意改变，故也可以使序列有序。 其余情况为NO。 #include &lt;bits/stdc++.h&gt; #define int long long using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(); while(c&gt;'9'||c&lt;'0') c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar(); } const int N=5e5+5; int n,c[N],rk[N], t; int ans; struct node { int id,w; bool operator &lt; (const node &amp;b) const { return w==b.w?id&lt;b.id:w&lt;b.w; } }a[N]; inline void insert(int x,int w) { for(;x&lt;=n;x+=x&amp;-x) c[x]+=w; } inline int query(int x) { int sum=0; for(;x;x-=x&amp;-x) sum+=c[x]; return sum; } signed main() { read(t); while(t--) { ans = 0; read(n); for(int i=1;i&lt;=n;i++) read(a[i].w),a[i].id=i; sort(a+1,a+1+n); bool flag = 0; for(int i = 2; i &lt;= n; i++) { if(a[i].w == a[i - 1].w) {flag = 1; break;} } if(flag) {puts(&quot;YES&quot;); continue;} for(int i=1;i&lt;=n;i++) rk[a[i].id]=i; for(int i=1;i&lt;=n;i++) { insert(rk[i],1); ans += i - query(rk[i]); } if(ans &amp; 1) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); for(int i = 0; i &lt;= n; i++) c[i] = rk[i] = 0; } return 0; } ","link":"https://gujinli.github.io/post/cf-1591-div2/"},{"title":"CF 1620 div2 赛后题解","content":"D - Exact Change 题意： n个价值为ai的物品。有1、2、3三种硬币，能表示出每个ai的价格最少需要多少枚硬币 Solution： 首先1和2的个数都不可能超过3个，因为3个的话显然用面额3表示价格更大。因此枚举使用的1和2的数量，再判断3的数量即可。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 105; int t, n, a[N], ans; /**/ int main() { read(t); while(t--) { read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); ans = 0x7f7f7f7f; for(int one = 0; one &lt;= 2; one++) { for(int two = 0; two &lt;= 2; two++) { int three = 0; for(int i = 1; i &lt;= n; i++) { int minnum = 0x7f7f7f7f; for(int use1 = 0; use1 &lt;= one; use1++) { for(int use2 = 0; use2 &lt;= two; use2++) { int res = a[i] - use1 - use2 * 2; if(res &gt;= 0 &amp;&amp; res % 3 == 0) { minnum = min(minnum, res / 3); } } } three = max(three, minnum); } ans = min(ans, three + one + two); } } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0; } E - Replace the Numbers 题意： 现在有q次操作， &quot;1 x&quot; — 在序列末尾添加一个x &quot;2 x y&quot; — 将序列中所有的x替换成y 输出这q次操作执行后的序列 Solution： 并查集瞎搞。注意x==y的时候特判continue掉就好了。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 5e5 + 5; int t, opt, x, y, n, fa[N], rec[N], a[N]; /**/ inline int find(int x){return x == fa[x] ? x : fa[x] = find(fa[x]);} int main() { read(t); while(t--) { read(opt); if(opt == 1) { read(x); ++n; if(rec[x]) fa[n] = fa[rec[x]]; else fa[n] = n, rec[x] = n, a[n] = x; } else { read(x); read(y); if(!rec[x] || x == y) continue; if(rec[y]) fa[find(rec[x])] = rec[y], rec[x] = 0; else { int f2 = find(rec[x]); rec[y] = f2; a[f2] = y; rec[x] = 0; } } } for(int i = 1; i &lt;= n; i++) { cout &lt;&lt; a[find(i)] &lt;&lt; ' '; } return 0; } ","link":"https://gujinli.github.io/post/cf-1620-div2-sai-hou-ti-jie/"},{"title":"ABC 232 赛后题解","content":"E - Rook Path 题意： 一个n∗mn*mn∗m的棋盘。初始点在 (x1,y1)(x1,y1)(x1,y1) ， 求通过 kkk 次移动后到达(x2,y2)(x2,y2)(x2,y2)的方案数。 注：每次移动可以 移至当前列/当前行的任意一点。（不能站着不动） Solution： 首先可以得出简单dp方程： fi,j,k=fi,j,k=∑j2j2≠jfi,j2,k−1+∑i2i2≠ifi2,j,k−1f_{i,j,k} = f_{i,j,k}=\\sum_{j2}^{j2\\ne j}f_{i,j2,k-1} + \\sum_{i2}^{i2\\ne i}f_{i2,j,k-1} fi,j,k​=fi,j,k​=j2∑j2​=j​fi,j2,k−1​+i2∑i2​=i​fi2,j,k−1​ 简单手模之后我们可以发现一个显然的规律就是，对于一个kkk值，fi,jf_{i,j}fi,j​只会有四个不同的取值，分别对应： f0,0=(x1,y1)f_{0,0} =(x1, y1)f0,0​=(x1,y1) f1,0=(x,y1)x≠x1f_{1,0} =(x, y1) \\quad x\\ne x1f1,0​=(x,y1)x​=x1 f0,1=(x1,y)y≠y1f_{0,1} =(x1, y) \\quad y\\ne y1f0,1​=(x1,y)y​=y1 f1,1=(x,y)x≠x1且y≠y1f_{1,1} =(x,y) \\quad x\\ne x1 且y\\ne y1f1,1​=(x,y)x​=x1且y​=y1 dp方程也很好推且很好理解。算是一道优化状态的好题。 #include &lt;bits/stdc++.h&gt; #define int long long using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int mod = 998244353; int n, m, t; int x1, Y1, x2, y2; int v00, v01, v10, v11; int f[2][2]; /**/ signed main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; cin &gt;&gt; x1 &gt;&gt; Y1 &gt;&gt; x2 &gt;&gt; y2; f[0][0] = 1; while(t--) { v00 = (f[1][0] * (n - 1) % mod + f[0][1] * (m - 1) % mod) % mod; v01 = (f[0][1] * (m - 2) % mod + f[1][1] * (n - 1) % mod + f[0][0]) % mod; v10 = (f[1][0] * (n - 2) % mod + f[1][1] * (m - 1) % mod + f[0][0]) % mod; v11 = (f[1][1] * (n + m - 4) % mod + f[0][1] + f[1][0]) % mod; f[0][0] = v00, f[0][1] = v01, f[1][0] = v10, f[1][1] = v11; } cin &gt;&gt; x1 &gt;&gt; Y1 &gt;&gt; x2 &gt;&gt; y2; if(x1 == x2 &amp;&amp; Y1 == y2) cout &lt;&lt; f[0][0]; else if(x1 == x2 &amp;&amp; Y1 != y2) cout &lt;&lt; f[0][1]; else if(x1 != x2 &amp;&amp; Y1 == y2) cout &lt;&lt; f[1][0]; else cout &lt;&lt; f[1][1]; return 0; } F - Simple Operations on Sequence **题意： ** 现有长度为nnn的序列AAA和BBB，可以对序列AAA进行以下两种代价分别为XXX和YYY的操作，求将AAA变为BBB的最小代价。 opt1： opt2： Solution： ","link":"https://gujinli.github.io/post/abc-232-sai-hou-ti-jie/"},{"title":"CF 1615 global 赛后题解","content":"C - Menorah 两个01串s1和s2。求最少的操作数把s1变为s2，不能则为-1 操作：固定一个1，其余位全部取反 我们的目标是让所有的位置变得相同。 考虑两个字符串相同的0**(00)和1(11)的数量，以及不同的0(01)和1(10)**的数量。 一个位置点两次是没有意义的，而连续点两个位置相当于交换了两个位置。（1和0） 所以对于当前不同的，即01，10：我们有两种策略： 点不同的位置。如果不同的位置的1和0数量相等，即可全部交换。因为点了偶数次所以对初始相等的不造成影响 点相同的位置。相同的位置点奇数次，即可让不同的位置变成相同，那么问题转换成了如何点奇数次使得相同的位置不变。 我们只需要让1的数量比0的数量多1，即可在偶数次交换01后使有一个11，而其他的全部不同。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5; int t, n, sc1, sc0, dc1, dc0; char s1[N], s2[N]; /**/ int main() { read(t); while(t--) { read(n); scanf(&quot;%s%s&quot;, s1 + 1, s2 + 1); sc1 = sc0 = dc1 = dc0 = 0; for(int i = 1; i &lt;= n; i++) { if(s1[i] == s2[i]) { if(s1[i] == '1') sc1++; else sc0++; } else { if(s1[i] == '1') dc1++; else dc0++; } } int ans = 0x3f3f3f3f; if(dc0 == dc1) ans = min(ans, dc0 + dc1); if(sc1 == sc0 + 1) ans = min(ans, sc1 + sc0); if(ans == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; '\\n'; else cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0; } D - X(or)-mas Tree 给定一个树，边权为-1表示未知。给定m个节点间路径异或和二进制1个数的奇偶性，判断能否构造一个合法的树满足条件 一个性质：设两个数为x,y。二进制下x有a个1，y有b个1。则： a ^ b = num_1(x ^ y) % 2 所以对于每个边权，我们只需要考虑其1的个数的奇偶性。把m条边加上后一起遍历判断，不确定的边利用异或的性质输出边权即可 注意这里用了内置的位运算函数，简单介绍一下 __builtin_ffs (unsigned int x)返回x的最后一位1的是从后向前第几位，比如7368（1110011001000）返回4 __builtin_clz (unsigned int x)返回前导的0的个数。 __builtin_ctz (unsigned int x) 返回后面的0个个数，和; builtin_clz相对。 __ builtin_popcount (unsigned int x) 返回二进制表示中1的个数。 __builtin_parity (unsigned int x) 返回x的奇偶校验位，也就是x的1的个数模2的结果。 #include &lt;bits/stdc++.h&gt; #define ll long long #define mp make_pair #define fi first #define se second #define pb push_back #define vi vector&lt;int&gt; #define pi pair&lt;int, int&gt; #define fr(a) freopen(a, &quot;r&quot;, stdin) #define fo(a) freopen(a, &quot;w&quot;, stdout); #define mod 998244353 template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;} template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;} ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;} using namespace std; const int maxn = 200005; /**/ int t, n, m, err; int dis[maxn], vis[maxn]; vector&lt;pi&gt;g[maxn]; /**/ void dfs(int u) { if(err) return; for(auto i:g[u]) { int v = i.fi, w = i.se; if(dis[v] == -1) { dis[v] = dis[u] ^ w; dfs(v); } else if(dis[v] != (dis[u] ^ w)) { err = 1; return; } } } void solve() { err = 0; vector&lt; array&lt;int, 3&gt; &gt;ed; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { g[i].clear(); dis[i] = -1; } for(int i = 1; i &lt; n; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; ed.pb({u, v, w}); if(w == -1) continue; w = __builtin_parity(w); g[u].pb({v, w}); g[v].pb({u, w}); } for(int i = 1; i &lt;= m; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].pb({v, w}); g[v].pb({u, w}); } for(int i = 1; i &lt;= n; i++) { if(dis[i] == -1) dis[i] = 0, dfs(i); } if(err) {puts(&quot;NO&quot;); return;} puts(&quot;YES&quot;); for(auto i: ed) { int u = i[0], v = i[1], w = i[2]; if(w == -1) w = dis[u] ^ dis[v]; printf(&quot;%d %d %d\\n&quot;, u, v, w); } } int main() { // fr(&quot;test.in&quot;); // fo(&quot;test.out&quot;); ios::sync_with_stdio(0);cin.tie(0); int T; cin &gt;&gt; T; while(T--) { solve(); } return 0; } E - Purple Crayon 一个初始全部为空白节点的树。红（先手）蓝两方轮流对其染色：（注：以下操作可以进行任意次） 红：选择一个空白子树将其全部染为红色。（注：一回合染色的节点数不能超过k） 蓝：选择任意个空白子树将其全部染为蓝色。（染色数无限制） 定义val = w(r-b) ，w：空白节点，r：红色，b：蓝色。 红方想让val最大化，蓝方想让b最小化。求双方均采取最优策略的情况下的val。 val=(n−r−b)(r−b)=r(n−r)−b(n−b)val = (n-r-b)(r-b) = r(n-r)-b(n-b)val=(n−r−b)(r−b)=r(n−r)−b(n−b) 首先对于蓝方来说，只需要最大化b(n-b) ，即选尽可能多的节点。 红方先选： k &gt;= 叶 把所有叶节点全选了使得b=0。此时 val = r(n-r)。显然r接近2/n时最小。即r=max(min(2/n,k),叶)r = max(min(2/n, k),叶)r=max(min(2/n,k),叶) k &lt; 叶 即此时红方没有办法保证蓝方无点可选，显然选择一个叶节点后可以叶 -&gt; 根上的所有路径全部被染色。因此问题变成了求选k个点尽可能多的染色。根据官方题解的做法，我们可以先求出每个点的深度，降序排序后dfs。到达根或一个已染色的节点后返回这条链的长度。将链长降序排序后选择最大的k个即可。 之后剩下的就只能由蓝方任意选择了，如果剩下的所有点&lt;=2/n则全选，如果 &gt; 2/n ，则只需选 2/n个即可。因为b = 2/n时使得结果最小化，且r再选只会使结果更小。（因为已经是负值了） 关于求这样的链长除了染色以外，从dmyls那里学习的另一种做法如下： mx[u] 表示 u 到最底端的链长。每次遍历到u时，将所有的mx[v]存进一个vector中，最大的作为u的链继续向上延伸，其余的加入最后统计的链长里即可。 非常妙www，虽然会因为排序操作使时间复杂度变大，但毫无影响。 #include &lt;bits/stdc++.h&gt; #define ll long long #define mp make_pair #define fi first #define se second #define pb push_back #define vi vector&lt;int&gt; #define pi pair&lt;int, int&gt; #define mod 998244353 template&lt;typename T&gt; bool chkmin(T &amp;a, T b){return (b &lt; a) ? a = b, 1 : 0;} template&lt;typename T&gt; bool chkmax(T &amp;a, T b){return (b &gt; a) ? a = b, 1 : 0;} ll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b &gt;&gt; 1); ns = ns * ns % mod; if (b &amp; 1) ns = ns * a % mod; return ns;} using namespace std; const int maxn = 200005; /**/ int n, k, mx[maxn], r, b; vi eg[maxn]; vi cur; /**/ void dfs(int u, int fa) { if(eg[u].size() == 1 &amp;&amp; fa) { mx[u] = 1; return; } vi cr; for(auto v : eg[u]) { if(v == fa) continue; dfs(v, u); cr.pb(mx[v]); } sort(cr.begin(), cr.end()); mx[u] = cr[cr.size() - 1] + 1; for(int i = 0; i &lt; cr.size() - 1; i++) cur.pb(cr[i]); } int main() { // freopen(&quot;test.in&quot;, &quot;r&quot;, stdin); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt; n; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); eg[u].pb(v), eg[v].pb(u); } // puts(&quot;ok1&quot;); dfs(1, 0); cur.pb(mx[1]); sort(cur.begin(), cur.end()); reverse(cur.begin(), cur.end()); if(k &gt; cur.size()) { b = 0; r = min(k, n / 2); if(r &lt; cur.size()) r = cur.size(); } else { r = k; b = n; for(int i = 0; i &lt; k; i++) b -= cur[i]; if(b &gt; n / 2) b = n / 2; } ll ans = 1ll * (n - r - b) * (r - b); cout &lt;&lt; ans &lt;&lt; '\\n'; return 0; } ","link":"https://gujinli.github.io/post/cf-1615-global-sai-hou-ti-jie/"},{"title":"CF 1619 div3 赛后题解","content":"A Square String? 题意： 判断一个串是否可以由两个串拼接而成。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } int t; string s; /**/ int main() { read(t); while(t--) { cin &gt;&gt; s; int n = s.length(); if(n &amp; 1) {puts(&quot;NO&quot;); continue;} if(s.substr(0, n/2) == s.substr(n/2, n/2)) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0; } B Squares and Cubes 题意： 判断n以内有多少正整数是平方/立方数。 #include &lt;bits/stdc++.h&gt; #define int long long using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ int t, n, ans; /**/ signed main() { read(t); while(t--) { read(n); ans = 0; for(int i = 1; i * i &lt;= n; i++) { ans++; int num = i * i * i; if(num &gt; n) continue; int x = sqrt(num); if(x * x == num) continue; ans++; } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0; } C Wrong Addition 题意： 定义傻子加法为：按位相加后把结果直接写在答案里。即：17236 + 03465 = 1106911 Solution： 注意细节简单模拟即可。 #include &lt;bits/stdc++.h&gt; #define PII pair&lt;int, int&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 50; int t; char a[N], s[N]; /**/ int main() { read(t); while(t--) { scanf(&quot;%s%s&quot;,a+1,s+1); int l1 = strlen(a + 1), l2 = strlen(s + 1); vector&lt;int&gt;ans; int i, j; for(i = l2, j = l1; i; i--) { int num1, num2; if(j) num1 = a[j--] - '0'; else num1 = 0; num2 = s[i] - '0'; if(num1 &gt; num2 &amp;&amp; i == 1) break; if(num1 &gt; num2) num2 = num2 + 10 * (s[--i] - '0'); if(num2 - num1 &gt; 9 || num2 - num1 &lt; 0) break; ans.push_back(num2 - num1); } if(j != 0 || i != 0) {puts(&quot;-1&quot;);continue;} int sz = ans.size(); bool flag = 0; for(int k = sz-1; k &gt;= 0; k--) { if(!flag &amp;&amp; !ans[k]) continue; flag = 1; cout &lt;&lt; ans[k]; } puts(&quot;&quot;); } return 0; } D New Year's Problem 题意： n个人。m个商店。 每个商店有对应n个人的n个礼物，每个礼物有一个满意度ai,ja_{i,j}ai,j​ ，选择 n−1n-1n−1 个商店使得：所有人能/获得的最大满意度的最小值最大。 Solution： 定义lie[i]lie[i]lie[i] 表示第iii 个人的最大满意度。 显然，n个人选择n个商店的话，只需要把n个人最大满意度所在的商店选择即可。 根据鸽巢原理，n个人选择n-1的话，必然有两列的最优值在同一行。 我们枚举商店，选择一个商店记录其最大和次大，除去这两个人后，剩下的全部选择最大值即可。 复杂度O(nm)O(nm)O(nm) #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } const int N = 1e5 + 5; int t, n, m, ans, lie[N], pos1, pos2; int main() { read(t); while(t--) { read(m); read(n); ans = 0; vector&lt;int&gt;v[m+2]; for(int i = 1; i &lt;= m; i++) { v[i].push_back(0); for(int j = 1, x; j &lt;= n; j++) { lie[j] = 0; read(x); v[i].push_back(x); } } for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { lie[i] = max(lie[i], v[j][i]); } } for(int i = 1; i &lt;= m; i++) { pos1 = pos2 = 0; for(int j = 1; j &lt;= n; j++) { if(v[i][j] &gt; v[i][pos1]) pos2 = pos1, pos1 = j; else if(v[i][j] &gt; v[i][pos2]) pos2 = j; } int maxnum = min(v[i][pos1], v[i][pos2]); for(int j = 1; j &lt;= n; j++) { if(j == pos1 || j == pos2) continue; maxnum = min(maxnum, lie[j]); } ans = max(ans, maxnum); } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0; } E MEX and Increments 题意： 给定一个长度为n的数列满足每个数都&lt;=n。每次操作可以将某个数+1。求使序列mex = {0...n} 的最小操作次数。 Solution： 当我们求 i 时， 如果 0...i-1 所有数都有，则 ans[i]ans[i]ans[i] = 当前数列中 i 的数量。（开个桶记录即可） 如果求到第 i 个，没有 i 则ans[i]=0ans[i] = 0ans[i]=0 ，同时从前面的 tottottot 中找一个离得最近且 &gt;2&gt;2&gt;2 的数，将其变成 iii 。 #include &lt;bits/stdc++.h&gt; #define int long long using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } const int N = 2e5 + 5; int t, n, tot[N], a[N], lst, rec, pre[N]; signed main() { read(t); while(t--) { read(n); memset(tot, 0, sizeof(tot)); for(int i = 1; i &lt;= n; i++) { read(a[i]); tot[a[i]]++; pre[i] = i - 1; } pre[0] = -1; sort(a + 1, a + 1 + n); lst = -1, rec = 0; for(int i = 0; i &lt;= n; i++) { if(tot[i]) { cout &lt;&lt; rec + tot[i] &lt;&lt; ' '; if(tot[i] &gt; 1) pre[i] = lst, lst = i; } else { cout &lt;&lt; rec &lt;&lt; ' '; if(lst == -1 || tot[lst] &lt; 2) { for(int j = i+1; j &lt;= n; j++) cout &lt;&lt; -1 &lt;&lt;' '; break; } rec += i - lst; tot[lst]--; while(lst != -1 &amp;&amp; tot[lst] &lt; 2) lst = pre[lst]; pre[i] = lst; tot[i]++; } } puts(&quot;&quot;); } return 0; } F. Let's Play the Hat? 题意： n个人m张桌子玩k次游戏。每个人必须玩k次游戏。每个桌子的人数都是 n/m （上取整 或 下取整）。 定义 bib_ibi​ 为第iii 个人在人数为 n/m(上取整) 的桌子上玩的游戏次数。对任意 $ i, j $ 满足 ∣bi−bj∣&lt;=1|b_i - b_j| &lt;= 1∣bi​−bj​∣&lt;=1 Solution： 首先，m张桌子分给n个人，显然每张桌子的人数是确定的—— 大桌为n%m个，小桌为 m - n%m个。（每张桌子先坐 n/m（下取整）个人，剩下的 n%m 个人随便挑一个坐） 我们要使每个人在大桌上坐的次数相差不超过1。策略是这样的： 每次让坐在大桌上次数较少的人坐大桌，坐不满从较多的人补。这样显然可以保证相差不超过1。 实现的话可以考虑利用vector的rotate来滚动选择的人，每次坐大桌的人都让其移动到整个序列的最后排队。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } const int N = 2e5 + 5; int t, n, m, k; int main() { read(t); while(t--) { read(n); read(m); read(k); vector&lt;int&gt;v(n); for(int i = 0; i &lt; n; i++) v[i] = i + 1; int bt = n % m, bn = ceil(1.0 * n / m), sn = n / m; for(int i = 1; i &lt;= k; i++) { int pos = 0; for(int j = 1, num; j &lt;= m; j++) { if(j &lt;= bt) num = bn; else num = sn; cout &lt;&lt; num &lt;&lt; ' '; while(num--) cout &lt;&lt; v[pos++] &lt;&lt; ' '; puts(&quot;&quot;); } rotate(v.begin(), v.begin() + bn * bt, v.end()); } puts(&quot;&quot;); } return 0; } G. Unusual Minesweeper 题意： 有n个地雷。已知地雷爆炸半径k （按十字形爆炸）和每个地雷的坐标即爆炸时间。 一个地雷爆炸后会瞬间引爆 十字形 上的所有其他地雷，定义该传递的时间是瞬间完成的（即0s）。 同时，我们每一秒还可以选择一个未爆炸的地雷点燃，求最快几s可以让所有的地雷爆炸。（从第0s开始，每s一个） Solution： 用并查集将互相影响的所有地雷丢进一个集合，得到每个集合的最小爆炸时间。 将该时间递增排序后，枚举第 i...ni ... ni...n 个地雷是人为引爆的 则时间为 max(n−i,ti[i−1])max(n-i, ti[i-1])max(n−i,ti[i−1])。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } const int N = 2e5 + 5; int t, n, k, ans, tot[N], fa[N], ti[N]; bool vis[N]; struct node { int x, y, t, id; }a[N]; inline bool cmp1(node i, node j) { if(i.x == j.x) return i.y &lt; j.y; return i.x &lt; j.x; } inline bool cmp2(node i, node j) { if(i.y == j.y) return i.x &lt; j.x; return i.y &lt; j.y; } inline int find(int x) {return x == fa[x] ? x : fa[x] = find(fa[x]);} inline void merge(int i, int j) { int f1 = find(i), f2 = find(j); if(f1 == f2) return; if(ti[f1] &lt; ti[f2]) fa[f2] = f1; else fa[f1] = f2; } int main() { read(t); while(t--) { read(n); read(k); tot[0] = 0; for(int i = 1; i &lt;= n; i++) { read(a[i].x); read(a[i].y); read(a[i].t); a[i].id = i; fa[i] = i; ti[i] = a[i].t; vis[i] = 0; } sort(a + 1, a + 1 + n, cmp1); for(int i = 1; i &lt; n; i++) if(a[i].x == a[i + 1].x &amp;&amp; a[i + 1].y - a[i].y &lt;= k) merge(a[i].id, a[i + 1].id); sort(a + 1, a + 1 + n, cmp2); for(int i = 1; i &lt; n; i++) if(a[i].y == a[i + 1].y &amp;&amp; a[i + 1].x - a[i].x &lt;= k) merge(a[i].id, a[i + 1].id); for(int i = 1; i &lt;= n; i++) { int f1 = find(i); if(!vis[f1]) vis[f1] = 1, tot[++tot[0]] = ti[f1]; } sort(tot + 1, tot + 1 + tot[0]); ans = min(tot[tot[0]], tot[0] - 1); for(int i = tot[0]; i &gt;= 1; i--) { int num = tot[0] - i + 1; ans = min(ans, max(num - 1, tot[i - 1])); } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0; } H. Permutation and Queries 题意： 长度为 nnn 的一个排列 pi(1≤i≤n)p_{i} (1\\le i \\le n)pi​(1≤i≤n) ，对其进行两种类型的 qqq 次 操作。 OPT 1 x y ： swap(px,py)swap(p_x, p_y)swap(px​,py​) OPT 2 i k : print the number that iii will become if we assign i=pii=p_ii=pi​ for kkk times. Solution： 待补。 ","link":"https://gujinli.github.io/post/cf-762-div3-sai-hou-ti-jie/"},{"title":"漫漫ACM之路","content":"图论： **生成树问题： ** 最小生成树 次小生成树(非严格/严格) 瓶颈生成树 kruscal重构树 最小树形图 最小直径生成树 树上问题: 基础性质 (直径,重心) 最近公共祖先(LCA) 树上启发式合并(dsu on tree) 虚树 树链剖分 重链剖分 长链剖分 树分治: 点分治 边分治 点分树 动态树分治 树同构: AHU 树哈希 最短路问题： Johnson 全源最短路径算法 分层图最短路 k短路 同余最短路 差分约束 连通问题: 强连通分量 双连通分量 割点和桥 圆方树 2-SAT 特殊图问题: 欧拉图 哈密顿图 二分图 图的着色 平面图 特殊应用: 斯坦纳树 矩阵树定理 ","link":"https://gujinli.github.io/post/man-man-acm-zhi-lu/"},{"title":"杂记","content":"bitset bitset是像bool数组一样的东西。但每个位置只占1bit。 一定程度上节省了空间和时间，一般来说会让算法复杂度/32。 定义与初始化： 头文件：#include&lt;bitset&gt; 定义时需指明所占用的空间（类数组）：bitset&lt;114514&gt;bit; 初始化可以用string或int（整数类型）： bitset&lt;23&gt;bit (string(&quot;11101001&quot;)); bitset&lt;23&gt;bit = 233; 常用函数： bit.size() 返回大小（位数） bit.count() 返回1的个数 bit.any() 返回是否有1 bit.none() 返回是否没有1 bit.set() 全都变成1 bit.set(p) 将第p + 1位变成1（bitset是从第0位开始的！） bit.set(p, x) 将第p + 1位变成x bit.reset() 全都变成0 bit.reset(p) 将第p + 1位变成0 bit.flip() 全都取反 bit.flip(p) 将第p + 1位取反 bit.to_ulong() 返回它转换为unsigned long的结果，如果超出范围则报错 bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错 bit.to_string() 返回它转换为string的结果 杂stl rotate ：用于vector rotate(a, b, c) 把 b ~ c 的元素放到 a 前面。 把[a ~ b) 和 [b, c) 互换 高效位运算 __builtin_ffs (unsigned int x)返回x的最后一位1的是从后向前第几位，比如7368（1110011001000）返回4 __builtin_clz (unsigned int x)返回前导的0的个数。 __builtin_ctz (unsigned int x) 返回后面的0个个数，和; builtin_clz相对。 __ builtin_popcount (unsigned int x) 返回二进制表示中1的个数。 __builtin_parity (unsigned int x) 返回x的奇偶校验位，也就是x的1的个数模2的结果。 ","link":"https://gujinli.github.io/post/za-ji/"},{"title":"ICPC2021沈阳 部分题解","content":"E. Edward Gaming, the Champion(签到题) 题意： 求一个字符串s中有多少个&quot;edgnb&quot; Solution： EDGNBEDGNBEDGNB #include &lt;bits/stdc++.h&gt; using namespace std; /**/ const int N = 2e5 + 5; char s[N]; /**/ int main() { scanf(&quot;%s&quot;, s); int len = strlen(s), ans = 0; for(int i = 0; i &lt; len; i++) { if(i+4&gt;=len) break; if(s[i]=='e'&amp;&amp;s[i+1]=='d'&amp;&amp;s[i+2]=='g'&amp;&amp;s[i+3]=='n'&amp;&amp;s[i+4]=='b') ans++, i = i + 4; } cout&lt;&lt;ans; return 0; } F. Encoded Strings I（签到题/模拟） 题意： 队友A的，待补。 Solution： 队友A的，待补。 #include &lt;bits/stdc++.h&gt; #define il inline #define ll long long #define Max 1005 #define int ll using namespace std; il ll read() { char c=getchar(); ll x=0,f=1; while(c&gt;'9'||c&lt;'0') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { x=x*10+c-'0'; c=getchar(); } return x*f; } int n,a[Max],c[Max],id[Max]; char s[Max],t[Max][Max]; il bool cmp(int x,int y) { int l=min(strlen(t[x]+1),strlen(t[y]+1)); for(int i=1;i&lt;=l;i++) { if(t[x][i]&lt;t[y][i]) return 0; if(t[x][i]&gt;t[y][i]) return 1; } return strlen(t[x]+1)&gt;strlen(t[y]+1); } signed main() { n=read(); scanf(&quot;%s&quot;,s+1); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=26;j++) c[j]=0; int tot=0; for(int j=i;j&gt;=1;j--) { if(!c[s[j]-'a'+1]) t[i][j]=tot+'a',c[s[j]-'a'+1]=++tot; else t[i][j]=c[s[j]-'a'+1]+'a'-1; //cout&lt;&lt;j&lt;&lt;' '&lt;&lt;c[s[j]-'a'+1]&lt;&lt;' '&lt;&lt;s[j]&lt;&lt;' '&lt;&lt;tot&lt;&lt;&quot; qwq\\n&quot;; } } //for(int i=1;i&lt;=n;i++) puts(t[i]+1); for(int i=1;i&lt;=n;i++) id[i]=i; sort(id+1,id+1+n,cmp); puts(t[id[1]]+1); } J. Luggage Lock（bfs） 题意： 一个四位数密码。给定起始状态 A 和终止状态 B 。每次可以选择一段区间向上拧或向下拧（即+1/−1+1/-1+1/−1）。 求由A变为B的最小操作次数。 Solution： 因为所有的两组状态都可以转化成 起始状态为 0000。因此对于 0000 开始，其实只有 10000 种状态。 预处理：利用 bfs 求最少步数。同时对已经得到的状态进行标记即可。 然后即可对每组询问 O(1) 输出。 #include &lt;bits/stdc++.h&gt; #define PII pair&lt;string,int&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const string opt[15] = {&quot;0001&quot;,&quot;0011&quot;,&quot;0111&quot;,&quot;1111&quot;,&quot;0010&quot;,&quot;0110&quot;,&quot;1110&quot;,&quot;0100&quot;,&quot;1100&quot;,&quot;1000&quot;}; int vis[10005], ans[10005]; /**/ inline int get(string s) { int ret = 0; for(int i=0;i&lt;4;i++) ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+s[i]-'0'; return ret; } inline string work(string s,int p,int flag) { string ret = s; for(int i=0;i&lt;4;i++) { if(opt[p][i]=='0') continue; ret[i]=(ret[i]-'0'+flag+10)%10+'0'; } return ret; } int main() { queue&lt;PII&gt;q; q.push(PII(&quot;0000&quot;,0)); vis[0] = 1; while(!q.empty()) { PII t = q.front(); q.pop(); string u = t.first; int step = t.second; for (int i = 0; i &lt; 10; i++) { string s1 = work(u,i,1); string s2 = work(u,i,-1); int num1 = get(s1), num2 = get(s2); if(!vis[num1]) { vis[num1]=1; ans[num1]=step + 1; q.push(PII(s1, step + 1)); } if(!vis[num2]) vis[num2] = 1, ans[num2] = step + 1, q.push(PII(s2, step + 1)); } } int t; read(t); string S1, S2, T; while(t--) { cin &gt;&gt; S1 &gt;&gt; S2; int ret = 0; for(int i=0;i&lt;4;i++) { ret = ret * 10 + (S2[i]-S1[i]+10)%10; } cout &lt;&lt; ans[ret] &lt;&lt; '\\n'; } return 0; } B. Bitwise Exclusive-OR Sequence（铜牌题） 题意： 一段长度为 nnn 的数。给定 mmm 组关系。每组关系 (u,v,w)(u,v,w)(u,v,w) 描述了：au⊕av=wa_u \\oplus a_v=wau​⊕av​=w 求这组数 各元素和 的最小值。 Solution： 可以根据每组关系建边，随意以一个有出边的点为树根进行遍历。 定义 dis[u]dis[u]dis[u] 为 从根节点到 uuu 的边权异或和。根据异或性质易知：art⊕au=disua_{rt} \\oplus a_u = dis_uart​⊕au​=disu​ 如果出现两个不同值的 dis[u]dis[u]dis[u] 则数据出现矛盾输出 -1。 对该森林的其中一个树，tot[i]tot[i]tot[i] 表示所有 dis[u]dis[u]dis[u] 的第 iii 位为1的数量。超过一半则让根该位为1更优，否则让根该位为0。 #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5, M = 4e5 + 5; int n, m, head[N], cnt, dis[N], tot[N], vis[N], sum; bool err; ll ans; struct edge { int nxt, to, w; }e[M]; /**/ inline void add(int u, int v, int w) { e[++cnt] = (edge){head[u], v, w}; head[u] = cnt; } void dfs(int u, int fa, int ti) { if(err) return; for(int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa) continue; if(vis[v]) { if((dis[u] ^ e[i].w) == dis[v]) continue; else {err = 1; return;} } vis[v] = ti; dis[v] = (dis[u] ^ e[i].w); sum++; for(int j = 0; j &lt;= 30; j++) { if(dis[v] &amp; (1&lt;&lt;j)) tot[j]++; } dfs(v, u, ti); if(err) return; } } int main() { read(n); read(m); for(int i = 1, u, v, w; i &lt;= m; i++) { read(u); read(v); read(w); if(u==v) { if(w) err = 1; continue; } add(u, v, w); add(v, u, w); } if(err) {puts(&quot;-1&quot;);return 0;} for(int i = 1; i &lt;= n; i++) { if(!head[i]) continue; if(vis[i]) continue; vis[i] = i; dfs(i, 0, i); sum++; for(int j = 0; j &lt;= 30; j++) { ans += 1ll * min(tot[j], sum - tot[j]) * (1 &lt;&lt; j); tot[j] = 0; } sum = 0; if(err) {puts(&quot;-1&quot;); return 0;} } if(err) {puts(&quot;-1&quot;); return 0;} cout &lt;&lt; ans &lt;&lt; '\\n'; return 0; } L. Perfect Matchings（树形dp+容斥） 题意： 队友A的，待补。 Solution： 队友A的，待补。 #include &lt;bits/stdc++.h&gt; #define il inline #define ll long long #define Max 4010 #define Mod 998244353 #define int ll using namespace std; il ll read() { char c=getchar(); ll x=0,f=1; while(c&gt;'9'||c&lt;'0') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { x=x*10+c-'0'; c=getchar(); } return x*f; } struct node { int t,nt; }e[Max&lt;&lt;1]; int n,head[Max],tot,f[Max][Max][2],g[Max],sz[Max],ans; il void add(int u,int v) { e[++tot].t=v; e[tot].nt=head[u]; head[u]=tot; } il void dfs(int u,int fa) { sz[u]=1; for(int i=head[u];i;i=e[i].nt) { int v=e[i].t; if(v==fa) continue; dfs(v,u); sz[u]+=sz[v]; } int s=1; //f[u][0][0]=1; f[u][0][0]=1; for(int i=head[u];i;i=e[i].nt) { int v=e[i].t; if(v==fa) continue; for(int j=s/2+1;j&gt;=0;j--) { for(int k=1;k&lt;=sz[v]/2+1;k++) { //if(j==0&amp;&amp;k==0) continue; f[u][j+k][0]=(f[u][j+k][0]+f[u][j][0]*f[v][k][0]+f[u][j][0]*f[v][k][1])%Mod; //f[u][0][0]=1; f[u][j+k][1]=(f[u][j+k][1]+f[u][j][0]*f[v][k-1][0]+f[u][j][1]*(f[v][k][0]+f[v][k][1]))%Mod; //cout&lt;&lt;u&lt;&lt;' '&lt;&lt;v&lt;&lt;' '&lt;&lt;j&lt;&lt;' '&lt;&lt;k&lt;&lt;' '&lt;&lt;f[1][1][1]&lt;&lt;&quot; qwq\\n&quot;; } } s+=sz[v]; } } signed main() { n=read()*2; for(int i=1;i&lt;n;i++) { int u=read(),v=read(); add(u,v),add(v,u); } g[0]=1; for(int i=2;i&lt;=n;i+=2) g[i]=(i-1)*g[i-2]%Mod; dfs(1,0); //for(int i=0;i&lt;=n/2;i++) cout&lt;&lt;f[1][i][1]&lt;&lt;' '&lt;&lt;f[1][i][0]&lt;&lt;endl; for(int i=0;i&lt;=n/2;i++) { ans=ans+(g[n-i*2]*(f[1][i][1]+f[1][i][0])%Mod*(i&amp;1?-1:1)+Mod); ans=(ans+Mod)%Mod; } cout&lt;&lt;ans&lt;&lt;endl; } M. String Problem（KMP） 题意： 给定一个长度为 nnn 的字符串s。输出 nnn 行 (li,ri)(l_i, r_i)(li​,ri​) 表示： 对 s 的前缀 s1...is_{1...i}s1...i​ 中字典序最大的子串。 Solution： 首先容易得到 ri=ir_i = iri​=i。然后做了一个神奇的 KMP 。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e6 + 5; char s[N]; int nxt[N]; int main() { scanf(&quot;%s&quot;, s + 1); int len = strlen(s + 1); puts(&quot;1 1&quot;); int pos = 1, j = 1; for(int i = 2; i &lt;= len; i++) { while(j &amp;&amp; s[i] &gt; s[pos + nxt[j]]) { pos += (j - nxt[j]); j = nxt[j]; } if(j &amp;&amp; s[i] == s[pos + nxt[j]]) { j++; nxt[j] = nxt[j - 1] + 1; } else nxt[++j] = 0; printf(&quot;%d %d\\n&quot;, pos, i); } return 0; } ","link":"https://gujinli.github.io/post/icpc2021-shen-yang-bu-fen-ti-jie/"},{"title":"ICPC2021上海 部分题解","content":" 场外一共做了六道题，罚时大概是银末的位置、场上的话估计只能铜。 题目质量还是挺高的很有意思。 E Strange Integers（签到题） 题意： 一段长度为n的序列。从中选出尽可能多的数，使任意两个数之间的绝对值相差大于k。 Solution： 对序列排序后从小到大。最小的数一定选，之后的从小到大能选就选。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5; int n, k, a[N], ans, rec; /**/ int main() { read(n); read(k); for(int i = 1; i &lt;= n; i++) read(a[i]); sort(a + 1, a + 1 + n); rec = -1000000000; for(int i = 1; i &lt;= n; i++) { // cout &lt;&lt; if(a[i] - rec &gt;= k) rec = a[i], ans++; } cout &lt;&lt; ans &lt;&lt; '\\n'; return 0; } D Strange Fractions（签到题） 题意： 给定p和q。求一组合法的a和b满足： pq=ab+ba\\frac{p}{q} = \\frac{a}{b} + \\frac{b}{a} qp​=ba​+ab​ Solution： 先推式子： pq=a2+b2abp+2qq=(a+b)2ab(p+2q)2q(p+2q)=(a+b)2ab\\frac{p}{q} = \\frac{a^2+b^2}{ab}\\\\ \\frac{p+2q}{q} = \\frac{(a+b)^2}{ab}\\\\ \\frac{(p+2q)^2}{q(p+2q)} = \\frac{(a+b)^2}{ab}\\\\ qp​=aba2+b2​qp+2q​=ab(a+b)2​q(p+2q)(p+2q)2​=ab(a+b)2​ 得 a+b=p+2qab=q(p+2q)a + b = p + 2q\\quad{}ab = q(p + 2q)a+b=p+2qab=q(p+2q) 联立即可得到 aaa 和 bbb 。同除以 gcdgcdgcd 约分一下即可。 注： p+2qp + 2qp+2q 是完全平方数则有解， 否则无解。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ int t, p, q, num1, num2, num3, num4, a, b, g; /**/ signed main() { read(t); while(t--) { read(p); read(q); num1 = p + 2 * q;// a + b num2 = num1 * q;// ab num3 = num1 * num1 - 4 * num2;// (a - b) ^ 2 num4 = sqrt(num3);// a - b if(num4 * num4 != num3) puts(&quot;0 0&quot;); else { a = (num1 + num4) / 2; b = num1 - a; g = __gcd(a, b); a /= g; b /= g; cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\\n'; } } return 0; } G Edge Groups（树形dp） 题意： n（奇数）个点的树，n-1条边分成 n−12\\frac{n-1}{2}2n−1​组，每组两条边并且两条边要有一个公共点。求分组的方案数。 Solution： 首先。n个元素两两分组的方案数是 f[n]f[n]f[n] ，则有递推式 f[n]=f[n−2]∗(n−1)f[n] = f[n- 2] * (n - 1)f[n]=f[n−2]∗(n−1) 设dp[u]dp[u]dp[u]为uuu子树的方案数。bbb 表示uuu子树中点数为奇数的个数。 dp[u]={f[b]∗∏f[v] b is evenf[b+1]∗∏f[v]b is odddp[u] = \\begin{cases} f[b]*\\prod f[v] \\quad\\quad\\;\\; \\text{b is even} \\\\ f[b+1]*\\prod f[v] \\quad \\text{b is odd} \\end{cases} dp[u]={f[b]∗∏f[v]b is evenf[b+1]∗∏f[v]b is odd​ #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5, mod = 998244353; int n, sz[N]; ll f[N], dp[N]; vector&lt;int&gt;g[N]; /**/ void dfs(int u, int fa) { sz[u] = 1; dp[u] = 1; int cnt = 0; for(auto &amp;v : g[u]) { if(v == fa) continue; dfs(v, u); sz[u] += sz[v]; dp[u] = dp[u] * dp[v] % mod; if(sz[v] &amp; 1) cnt++; } if(cnt &amp; 1) cnt++; dp[u] = dp[u] * f[cnt] % mod; } signed main() { read(n); for(int i = 1, x, y; i &lt; n; i++) { read(x); read(y); g[x].push_back(y); g[y].push_back(x); } f[0] = 1; for(int i = 2; i &lt;= n; i += 2) { f[i] = f[i - 2] * (i - 1) % mod; } dfs(1, 0); cout &lt;&lt; dp[1]; return 0; } I Steadily Growing Steam（签到题/背包） 题意： n 个物品。每个物品有价值w[i] 和 体积 v[i]，求从中选出两个无交集的集合，两个集合的体积和相等，价值和最大。 注：可以将这n个物品中至多k个物品的体积翻倍。 Solution： 对选入两个集合分别用正负进行表示即可，注意边界问题的处理正常背包即可。 #include &lt;bits/stdc++.h&gt; using namespace std; #define ll long long inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ int n, k, w[105], v[105], m; ll f[105][3000][105], ans; /**/ int main() { read(n); read(k); ans = 0; for(int i = 1; i &lt;= n; i++) {read(w[i]); read(v[i]);} memset(f, -0x3f, sizeof(f)); f[0][1400][0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = 0; j &lt;= 2800; j++) { f[i][j][0] = max(max(f[i][j][0], f[i-1][j][0]), f[i-1][j+v[i]][0]+w[i]); if(j&gt;=v[i]) f[i][j][0] = max(f[i][j][0], f[i-1][j-v[i]][0]+w[i]); for(int t = 1; t &lt;= min(i, k); t++) { f[i][j][t] = max(max(f[i][j][t], f[i-1][j][t]), max(f[i-1][j+2*v[i]][t-1], f[i-1][j+v[i]][t])+w[i]); if(j&gt;=v[i]) f[i][j][t] = max(f[i][j][t], f[i-1][j-v[i]][t]+w[i]); if(j&gt;=2*v[i]) f[i][j][t] = max(f[i][j][t], f[i-1][j-2*v[i]][t-1]+w[i]); } } } for(int i = 0; i &lt;= k; i++) ans = max(ans, f[n][1400][i]); cout &lt;&lt; ans &lt;&lt; '\\n'; return 0; } K Circle of Life（银牌题/构造） 题意： 一个n位的由0和1组成的串。对每秒，1（星星）变成0向两边发射1，两个扩散的星星相撞则变成0。 Solution： 暴力打表找规律。找出某一循环的特殊性质后输出。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } inline void W(int x) {if(x&lt;0){putchar('-'),x=-x;}write(x);} /**/ int n; /**/ int main() { cin &gt;&gt; n; if(n == 3) {puts(&quot;Unlucky&quot;); return 0;} else { if(n&amp;1) printf(&quot;100&quot;),n-=3; n/=2; for(int i=1;i&lt;=n;i++) { if(i&amp;1) printf(&quot;01&quot;); else printf(&quot;10&quot;); } } return 0; } M Harmony in Harmony(银牌题/构造) 题意： 待补。 Solution： 瞎猜的。待补。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } int n,m; signed main() { read(n); for(int i=1;i&lt;=n;i++) { m=max(m,(n*(i)*(n-i+1))); } printf(&quot;%.9f&quot;,1.0/m); } H Life is a Game(铜牌题/kruscal重构树|可并堆) 题意： 对于n个点m条边的无向图有q个询问。图有点权和边权，每个询问 x,k 表示从 x 出发，初始能力值为k，当能力值大于边权则能通过这条边，第一次到达一个点可以获得该点点权的能力值。求可以获得的最大能力。 Solution： 对边按边权从小到大排序。询问离线，用n个堆维护每个点的询问（按k从小到大维护）。 枚举边，对边（无向）的两个端点，分别取出能力值不能通过这条边的询问，记录答案。 对于剩下的结点（全部能够通过这条边），利用并查集合并这两个节点，同时将堆按并查集的思路 启发式合并（小堆并大堆）。 枚举完边后对于剩余没有得到答案的询问（即合并完成的询问），单独取出并记录答案。 #include &lt;bits/stdc++.h&gt; #define PII pair&lt;int, int&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5; int n, m, t, sum[N], fa[N], ans[N]; struct edge { int from, to, w; bool operator &lt; (const edge &amp;b) const {return w &lt; b.w;} }e[N]; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt;q[N]; /**/ inline int find(int x){return x == fa[x] ? x : fa[x] = find(fa[x]);} int main() { read(n); read(m); read(t); for(int i = 1; i &lt;= n; i++) read(sum[i]), fa[i] = i; for(int i = 1, u, v, w; i &lt;= m; i++) read(u), read(v), read(w), e[i] = (edge){u, v, w}; sort(e + 1, e + 1 + m); for(int i = 1, x, k; i &lt;= t; i++) read(x), read(k), q[x].push(PII(k, i)); for(int i = 1; i &lt;= m; i++) { int u = find(e[i].from), v = find(e[i].to); if(u == v) continue; while(!q[u].empty() &amp;&amp; q[u].top().first + sum[u] &lt; e[i].w) { int id = q[u].top().second; ans[id] = q[u].top().first + sum[u]; q[u].pop(); } while(!q[v].empty() &amp;&amp; q[v].top().first + sum[v] &lt; e[i].w) { int id = q[v].top().second; ans[id] = q[v].top().first + sum[v]; q[v].pop(); } if(q[u].size() &gt; q[v].size()) swap(u, v); while(!q[u].empty()) q[v].push(q[u].top()), q[u].pop(); fa[u] = v; sum[v] += sum[u]; } for(int i = 1; i &lt;= n; i++) { int u = find(i); while(!q[u].empty()) { PII x = q[u].top(); q[u].pop(); ans[x.second] = x.first + sum[u]; } } for(int i = 1; i &lt;= t; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; return 0; } J Two Binary Strings Problem（银牌题/bitset） 题意： 给定长度为n的两个01串A和B。f(l,r)!f(l,r)!f(l,r)!表示区间lll到rrr的众数。（01数量相等时为0） 求一个长度同样为n的01串ansansans，anskans_kansk​为 1 时当且仅当：对所有1≤i≤n有f(max(i−k+1,1),i)=Bi1\\le i\\le n\\quad{有}f(max(i-k+1, 1), i) = B_i1≤i≤n有f(max(i−k+1,1),i)=Bi​ 成立 Solution： A 0 1 1 0 1 0 1K10 1 1 0 1 0 1K20 0 1 0 0 0 0K30 0 1 1 1 0 1K40 0 1 0 1 0 0K50 0 1 0 1 1 1K60 0 1 0 1 0 1K70 0 1 0 1 0 1A\\quad\\;\\; 0\\; 1\\; 1\\; 0\\; 1\\; 0\\; 1\\\\ K1\\quad 0\\; 1\\; 1\\; 0\\; 1\\; 0\\; 1\\\\ K2\\quad 0\\; 0\\; 1\\; 0\\; 0\\; 0\\; 0\\\\ K3\\quad 0\\; 0\\; 1\\; 1\\; 1\\; 0\\; 1\\\\ K4\\quad 0\\; 0\\; 1\\; 0\\; 1\\; 0\\; 0\\\\ K5\\quad 0\\; 0\\; 1\\; 0\\; 1\\; 1\\; 1\\\\ K6\\quad 0\\; 0\\; 1\\; 0\\; 1\\; 0\\; 1\\\\ K7\\quad 0\\; 0\\; 1\\; 0\\; 1\\; 0\\; 1\\\\ A0110101K10110101K20010000K30011101K40010100K50010111K60010101K70010101 对于每一行，若Ci=BC_i = BCi​=B ，则 ansi=1ans_i = 1ansi​=1 由于行之间的关系不好找，转成列 。 对于第i列，找到最近的 jjj使 j+1...ij+1...ij+1...i 的0和1相等。因为是最近的，故f(j+1,i)=0,而f(j+k,i)=Ai(1≤k≤i−j)故f(j+1,i)=0, 而f(j+k,i)=A_i (1\\le k \\le i-j)故f(j+1,i)=0,而f(j+k,i)=Ai​(1≤k≤i−j) 故对于CiC_iCi​的1...(i−j−1)1...(i-j-1)1...(i−j−1)项均=Ai=A_i=Ai​，第i−ji-ji−j项恰好=0=0=0。第(i−j+1)...n(i-j+1)...n(i−j+1)...n可由CjC_jCj​转移。 若找不到jjj，则CiC_iCi​全部等于AiA_iAi​。 难点其实在位运算的转移上。需要思考一下。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 5e4 + 5; int t, n, tot[N*2]; char A[N], B[N]; bitset&lt;N&gt;C[N], ans, all1; /**/ int main() { read(t); while(t--) { read(n); scanf(&quot;%s%s&quot;, A, B); for(int i = 0; i &lt; n; i++) all1[i] = 1, C[i] = 0; ans = all1; for(int i = 0; i &lt;= 2*n; i++) tot[i] = -2; tot[n] = -1; int rec = n; for(int i = 0; i &lt; n; i++) { A[i] == '1' ? ++rec : --rec; int j = tot[rec]; // printf(&quot;i = %d, j = %d\\n&quot;, i + 1, j); if(j == -2) A[i] == '1' ? C[i] = all1 : C[i] = 0; else { //1 -&gt; (i - j - 1) 位 = A[i] , 第 i - j 位 = 0 ( 0和1 恰好 相等) , 剩下的由之前的递推而来 if(A[i] == '1') C[i] |= all1 &gt;&gt; (n - (i - j - 1) ); //原来n位，变成(i-j-1)位 if(j != -1) C[i] |= C[j] &lt;&lt; (i - j); else if(C[i][i]) C[i] |= all1 &lt;&lt; i; // K &gt; (i - j); } // for(int k = 0; k &lt; n; k++) cout &lt;&lt; C[i][k]; puts(&quot;&quot;); tot[rec] = i; ans &amp;= (B[i]=='1' ? C[i] : ~C[i]); } for(int i = 0; i &lt; n; i++) cout &lt;&lt; ans[i]; putchar('\\n'); } return 0; } ","link":"https://gujinli.github.io/post/icpc2021-shang-hai-bu-fen-ti-jie/"},{"title":"搜索与图论","content":"DFS与BFS 注意剪枝，边界表示。 状态需要判重时，能不用map尽量不用，能用数字尽量不用字符串 树与图的遍历 正常遍历 拓扑排序：根据入度删点，入度为0的点加入队列bfs 最短路 floyd &amp; spfa &amp; dijkstra spfa：队头出队，松弛它的边，松弛了且不在队内的点入队。 判断负环： 判入队次数是否&gt;n 差分约束：按照dis[v]&lt;=dis[u]+wdis[v] &lt;= dis[u] + wdis[v]&lt;=dis[u]+w的形式建边求最短路或反之求最长路即可 差分约束最优解 最大值求最短路 最小值求最长路 dij：每次取出当前距离最小的点，表示该点的最短路已经确定。 反向建边 虚点建边 最小生成树 prim kruskal 次小生成树？ prim维护f[i][j] 表示最小生成树中 i到j 的最长边 kruscal + lca O(1)离线查询 i到j 的最长边 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define ll long long #define space putchar(' ') #define endl putchar('\\n') #define debug puts(&quot;------------------------&quot;) #define lowbit(x) (x&amp;-x) #define LOCAL using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } inline int Rem() {int a=0,c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();return a*=b; } inline void write(int x) {if(x&gt;9)write(x/10);putchar('0'+x%10);} inline void W(int x) {if(x&lt;0){putchar('-'),x=-x;}write(x);} /**/ const int inf = 0x3f3f3f3f; const int N = 105; int t,n,m,e[N][N],cnt,dis[N],s1,s2,pre[N],f[N][N]; bool tree[N][N], vis[N]; struct edge { int from,to,w; }ed[N*N]; /**/ int main() { #if ONLINE_JUDGE #else freopen(&quot;test.in&quot;,&quot;r&quot;,stdin); freopen(&quot;test.out&quot;,&quot;w&quot;,stdout); #endif read(t); while(t--) { cnt = 0; read(n);read(m); for(int i=1;i&lt;=n;i++) { pre[i] = 0; for(int j=1;j&lt;=i+1;j++) e[i][j] = e[j][i] = inf, tree[i][j] = tree[j][i] = 0, f[i][j] = f[j][i] = 0; } for(int i=1,a,b,c;i&lt;=m;i++) { read(a);read(b);read(c); ed[++cnt] = (edge){a,b,c}; e[a][b] = e[b][a] = c; } for(int i=0;i&lt;=n;i++) dis[i] = inf, vis[i] = 0; dis[1] = 0; s1 = 0; for(int i=1;i&lt;=n;i++) { int u = 0; for(int j=1;j&lt;=n;j++) if(!vis[j]&amp;&amp;dis[j]&lt;dis[u]) u = j; vis[u] = 1; tree[pre[u]][u] = tree[u][pre[u]] = 1; if(u) s1 += dis[u]; for(int j=1;j&lt;=n;j++) { if(u==j) continue; if(vis[j]) { f[j][u] = f[u][j] = max(f[pre[u]][j], dis[u]); } if(!vis[j] &amp;&amp; dis[j] &gt; e[u][j]) { dis[j] = e[u][j]; pre[j] = u; } } } s2 = inf; for(int i=1;i&lt;=cnt;i++) { int u = ed[i].from, v = ed[i].to; if(tree[u][v]) continue; // printf(&quot;%d - %d = %d\\n&quot;,u,v,f[u][v]); s2 = min(s2, s1 - f[u][v] + ed[i].w); } cout &lt;&lt; s1 &lt;&lt;' '&lt;&lt; s2 &lt;&lt;'\\n'; } return 0; } 有向图有根最小生成树？ -&gt; 朱刘算法 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define ll long long #define space putchar(' ') #define endl putchar('\\n') #define debug puts(&quot;------------------------&quot;) #define lowbit(x) (x&amp;-x) #define LOCAL using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } inline int Rem() {int a=0,c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();return a*=b; } inline void write(int x) {if(x&gt;9)write(x/10);putchar('0'+x%10);} inline void W(int x) {if(x&lt;0){putchar('-'),x=-x;}write(x);} /**/ const int N = 105, M = 1e4 + 5; int n, cnt, m, fa[N], id[N], vis[N]; double x[N], y[N], in[N]; struct edge { int from, to; double w; }e[M]; /**/ inline double get(int i, int j) { return sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])); } inline double zhuliu() { double ans = 0; int root = 1; while(1) { for(int i = 1; i &lt;= n; i++) in[i] = 0x3f3f3f3f; for(int i = 1; i &lt;= cnt; i++) { int u = e[i].from, v = e[i].to; if(u != v &amp;&amp; e[i].w &lt; in[v]) { fa[v] = u; in[v] = e[i].w; } } for(int i = 1; i &lt;= n; i++) if(in[i] == 0x3f3f3f3f) return -1; int tot = 0; in[root] = 0; for(int i = 1; i &lt;= n; i++) vis[i] = id[i] = 0; for(int i = 1; i &lt;= n; i++) { int u = i; ans += in[u]; while(vis[u] != i &amp;&amp; !id[u] &amp;&amp; u != root) vis[u] = i, u = fa[u]; if(u != root &amp;&amp; !id[u]) { id[u] = ++tot; for(int x = fa[u]; x != u; x = fa[x]) id[x] = tot; } } if(!tot) break; for(int i = 1; i &lt;= n; i++) if(!id[i]) id[i] = ++tot; int cnt_ = 0; for(int i = 1; i &lt;= cnt; i++) { int u = e[i].from, v = e[i].to; if(id[u] =! id[v]) e[++cnt_] = (edge){id[u], id[v], e[i].w - in[v]}; } cnt = cnt_; n = tot; root = id[root]; } return ans; } int main() { #if ONLINE_JUDGE #else freopen(&quot;test.in&quot;,&quot;r&quot;,stdin); freopen(&quot;test.out&quot;,&quot;w&quot;,stdout); #endif while(cin &gt;&gt; n &gt;&gt; m) { cnt = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; x[i] &gt;&gt; y[i]; } for(int i = 1, a, b; i &lt;= m; i++) { read(a); read(b); e[++cnt] = (edge){a, b, get(a, b)}; } double ans = zhuliu(); if(ans == -1) puts(&quot;poor snoopy&quot;); else printf(&quot;%.2f\\n&quot;, ans); } return 0; } 二分图： 待补习 ","link":"https://gujinli.github.io/post/sou-suo-yu-tu-lun/"},{"title":"动态规划基础","content":"线性dp： LIS： 严格上升：*lower_bound(f+1,f+1+n,a[i]) = a[i]; 非严格上升：*upper_bound(f+1,f+1+n,a[i]) = a[i]; LCS: 最长公共子序列 背包dp: 01背包：每种物品只能取一件 完全背包：每种物品可以取无数件 多重背包：每种物品有固定件数。 可进行二进制拆分优化。 分组背包：对不同组做背包就可以了。 区间dp: 枚举区间长度 枚举区间起点 枚举区间断点 树形dp: f[i][j]f[i][j]f[i][j] 中的 i 用来表示结点， j 用来表示状态信息。 状压dp： 数位dp： 记忆化搜索 类似dp。先写出dp方程然后在搜索中利用记忆化数组记录最优解。（剪枝？） ","link":"https://gujinli.github.io/post/dong-tai-gui-hua-ji-chu/"},{"title":"基础数据结构","content":"链表 单链表 双链表 基本没有正式用到的知识。像模拟的数据结构。 以 0 为 头节点， 1为尾节点。模拟实现即可。 循环链表 栈 先进后出 典例：表达式求值(acw 3302) 队列 先进先出 单调栈 维护一个单调的栈。每次弹栈时记录需要的信息 模板 例题 单调队列 维护一个单调的队列，记录信息，队首超出范围（或不符合当前要求）则弹出。 例题 kmp 字符串匹配。求串s在t中出现的次数。 记录一个 pi[i]pi[i]pi[i] 表示以 iii 为节点的串，前缀后缀相等的最大长度。 将s和t拼接起来，如果 pi[i]==npi[i] == npi[i]==n （n为s串长度）则证明出现了一次，ans++； 并查集 fa[i] 表示i节点的父节点。 压缩路径，按秩合并，带权并查集等常用思想。代码简单，难在灵活应用 堆 待补习，暂时用优先队列代替。 hash表 进制哈希。 使用自然溢出是否有必要模质数？ 是否有必要加一个小质数防止被卡？ 无特殊需求（如前缀和等）时，其实可以加。（但没啥很大意义） trie 字典树用边表示字母 有相同前缀的单词公用前缀节点，那我们可以的得出每个节点最多有26个子节点（在单词只包含小写字母的情况下） 整棵树的根节点是空的。为什么呢？便于插入和查找，这将会在后面解释。 每个单词结束的时候用一个特殊字符表示，图中用的 xxx ，那么从根节点到任意一个 xxx 所经过的边的所有字母表示一个单词。 有关异或：用01串建trie树，边为0或1。 ","link":"https://gujinli.github.io/post/ji-chu-shu-ju-jie-gou/"},{"title":"算法基础","content":"基础算法整理❗️ 排序 冒泡排序 O(n2)O(n^2)O(n2) n次遍历每次从1到n判断相邻的数字是否左小右大否则swap 选择排序 O(n2)O(n^2)O(n2) n次遍历每次找出最小数添加到一个新数组 插入排序 O(n2)O(n^2)O(n2) n次遍历每次将当前数添加到一个新数组末尾，并从后向前依次swap直到遇到一个小于等于当前数的数字。 希尔排序 O(n2)O(n^2)O(n2) n次遍历，每次将第i个数字与前面的数字swap知道遇到一个小于等于当前数的数字。 归并排序 O(nlogn)O(nlogn)O(nlogn) 每次将数组分成两段，分别处理好两段后合并起来。（递归） 快速排序 O(nlogn)O(nlogn)O(nlogn) 以中间数为基准数。双指针分别从前从后跑，遇到aia_iai​大于等于中间数aja_jaj​小于等于中间数则swap。直至$ i&gt;j。则。则。则j左边的数全部小于中间数，左边的数全部小于中间数，左边的数全部小于中间数，i$右边的数全部大于中间数。之后递归处理。 计数排序 O(n)O(n)O(n) 简易桶排序。每个数字放进对应的桶中++。遍历输出。 桶排序 O(n)O(n)O(n) 可以限定桶个数的升级桶排序。 二分 二分查找 二分答案 日报：二分边界问题 关于二分的问题在这份日报中讲的十分清晰。 分为两种方法，一种为记录中间值，另一种不记录。 不记录的情况则需要根据 l=midl = midl=mid 还是 l=mid+1l = mid + 1l=mid+1 小心死循环的情况。 总之遇到二分题的时候，认真思考判断边界的处理即可。 （当然直接使用记录中间值的方法也是一种不错的选择） 如果二分答案的值是小数，采取二分多次的方法（如1k或1w）来达到精度要求即可. 01分数规划： 待补习。 高精 sb 大模拟罢了 前缀和差分 前缀和: 线性 / 二(多)维 / 树上 还有基于dp的高维前缀和等等 差分: 维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的数。注意修改操作一定要在查询操作之前。 即多次区间加减，离线查询。 树上差分 ： 分为点差分和边差分。待补习。 双指针（又称尺取法） 日报：尺取法小结 维护两个指针 l,rl,rl,r ,每次确定区间的左端点,让 rrr 不断向右移动,直到满足条件停下,维护一下答案,直到 r&gt;nr&gt;nr&gt;n 或者其它情况 位运算 日报：二进制与位运算 离散化 离散化本质上可以看成是一种 哈希，其保证数据在哈希以后仍然保持原来的全/偏序关系。 通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。 用来离散化的可以是大整数、浮点数、字符串等等。 sort(lsh+1,lsh+1+n); cnt = unique(lsh+1,lsh+1+cnt) - lsh - 1; ID(x) = lower_bound(lsh+1,lsh+1+cnt,x) - lsh; 区间合并 (acwing 803) 给定n段区间，合并所有有交集的区间。 按左端点排序，贪心从左向右依次合并。 ","link":"https://gujinli.github.io/post/suan-fa-ji-chu/"}]}