{"posts":[{"title":"ICPC2021沈阳 部分题解","content":"待补 ","link":"https://gujinli.github.io/post/icpc2021-shen-yang-bu-fen-ti-jie/"},{"title":"ICPC2021上海 部分题解","content":" 场外一共做了六道题，罚时大概是银末的位置、场上的话估计只能铜。 题目质量还是挺高的很有意思。 E Strange Integers（签到题） 题意： 一段长度为n的序列。从中选出尽可能多的数，使任意两个数之间的绝对值相差大于k。 Solution： 对序列排序后从小到大。最小的数一定选，之后的从小到大能选就选。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5; int n, k, a[N], ans, rec; /**/ int main() { read(n); read(k); for(int i = 1; i &lt;= n; i++) read(a[i]); sort(a + 1, a + 1 + n); rec = -1000000000; for(int i = 1; i &lt;= n; i++) { // cout &lt;&lt; if(a[i] - rec &gt;= k) rec = a[i], ans++; } cout &lt;&lt; ans &lt;&lt; '\\n'; return 0; } D Strange Fractions（签到题） 题意： 给定p和q。求一组合法的a和b满足： pq=ab+ba\\frac{p}{q} = \\frac{a}{b} + \\frac{b}{a} qp​=ba​+ab​ Solution： 先推式子： pq=a2+b2abp+2qq=(a+b)2ab(p+2q)2q(p+2q)=(a+b)2ab\\frac{p}{q} = \\frac{a^2+b^2}{ab}\\\\ \\frac{p+2q}{q} = \\frac{(a+b)^2}{ab}\\\\ \\frac{(p+2q)^2}{q(p+2q)} = \\frac{(a+b)^2}{ab}\\\\ qp​=aba2+b2​qp+2q​=ab(a+b)2​q(p+2q)(p+2q)2​=ab(a+b)2​ 得 a+b=p+2qab=q(p+2q)a + b = p + 2q\\quad{}ab = q(p + 2q)a+b=p+2qab=q(p+2q) 联立即可得到 aaa 和 bbb 。同除以 gcdgcdgcd 约分一下即可。 注： p+2qp + 2qp+2q 是完全平方数则有解， 否则无解。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ int t, p, q, num1, num2, num3, num4, a, b, g; /**/ signed main() { read(t); while(t--) { read(p); read(q); num1 = p + 2 * q;// a + b num2 = num1 * q;// ab num3 = num1 * num1 - 4 * num2;// (a - b) ^ 2 num4 = sqrt(num3);// a - b if(num4 * num4 != num3) puts(&quot;0 0&quot;); else { a = (num1 + num4) / 2; b = num1 - a; g = __gcd(a, b); a /= g; b /= g; cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\\n'; } } return 0; } G Edge Groups（树形dp） 题意： n（奇数）个点的树，n-1条边分成 n−12\\frac{n-1}{2}2n−1​组，每组两条边并且两条边要有一个公共点。求分组的方案数。 Solution： 首先。n个元素两两分组的方案数是 f[n]f[n]f[n] ，则有递推式 f[n]=f[n−2]∗(n−1)f[n] = f[n- 2] * (n - 1)f[n]=f[n−2]∗(n−1) 设dp[u]dp[u]dp[u]为uuu子树的方案数。bbb 表示uuu子树中点数为奇数的个数。 dp[u]={f[b]∗∏f[v] b is evenf[b+1]∗∏f[v]b is odddp[u] = \\begin{cases} f[b]*\\prod f[v] \\quad\\quad\\;\\; \\text{b is even} \\\\ f[b+1]*\\prod f[v] \\quad \\text{b is odd} \\end{cases} dp[u]={f[b]∗∏f[v]b is evenf[b+1]∗∏f[v]b is odd​ #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ const int N = 1e5 + 5, mod = 998244353; int n, sz[N]; ll f[N], dp[N]; vector&lt;int&gt;g[N]; /**/ void dfs(int u, int fa) { sz[u] = 1; dp[u] = 1; int cnt = 0; for(auto &amp;v : g[u]) { if(v == fa) continue; dfs(v, u); sz[u] += sz[v]; dp[u] = dp[u] * dp[v] % mod; if(sz[v] &amp; 1) cnt++; } if(cnt &amp; 1) cnt++; dp[u] = dp[u] * f[cnt] % mod; } signed main() { read(n); for(int i = 1, x, y; i &lt; n; i++) { read(x); read(y); g[x].push_back(y); g[y].push_back(x); } f[0] = 1; for(int i = 2; i &lt;= n; i += 2) { f[i] = f[i - 2] * (i - 1) % mod; } dfs(1, 0); cout &lt;&lt; dp[1]; return 0; } I Steadily Growing Steam（签到题/背包） 题意： n 个物品。每个物品有价值w[i] 和 体积 v[i]，求从中选出两个无交集的集合，两个集合的体积和相等，价值和最大。 注：可以将这n个物品中至多k个物品的体积翻倍。 Solution： 对选入两个集合分别用正负进行表示即可，注意边界问题的处理正常背包即可。 #include &lt;bits/stdc++.h&gt; using namespace std; #define ll long long inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } /**/ int n, k, w[105], v[105], m; ll f[105][3000][105], ans; /**/ int main() { read(n); read(k); ans = 0; for(int i = 1; i &lt;= n; i++) {read(w[i]); read(v[i]);} memset(f, -0x3f, sizeof(f)); f[0][1400][0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = 0; j &lt;= 2800; j++) { f[i][j][0] = max(max(f[i][j][0], f[i-1][j][0]), f[i-1][j+v[i]][0]+w[i]); if(j&gt;=v[i]) f[i][j][0] = max(f[i][j][0], f[i-1][j-v[i]][0]+w[i]); for(int t = 1; t &lt;= min(i, k); t++) { f[i][j][t] = max(max(f[i][j][t], f[i-1][j][t]), max(f[i-1][j+2*v[i]][t-1], f[i-1][j+v[i]][t])+w[i]); if(j&gt;=v[i]) f[i][j][t] = max(f[i][j][t], f[i-1][j-v[i]][t]+w[i]); if(j&gt;=2*v[i]) f[i][j][t] = max(f[i][j][t], f[i-1][j-2*v[i]][t-1]+w[i]); } } } for(int i = 0; i &lt;= k; i++) ans = max(ans, f[n][1400][i]); cout &lt;&lt; ans &lt;&lt; '\\n'; return 0; } K Circle of Life（银牌题/构造） 题意： 一个n位的由0和1组成的串。对每秒，1（星星）变成0向两边发射1，两个扩散的星星相撞则变成0。 Solution： 暴力打表找规律。找出某一循环的特殊性质后输出。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } inline void W(int x) {if(x&lt;0){putchar('-'),x=-x;}write(x);} /**/ int n; /**/ int main() { cin &gt;&gt; n; if(n == 3) {puts(&quot;Unlucky&quot;); return 0;} else { if(n&amp;1) printf(&quot;100&quot;),n-=3; n/=2; for(int i=1;i&lt;=n;i++) { if(i&amp;1) printf(&quot;01&quot;); else printf(&quot;10&quot;); } } return 0; } M Harmony in Harmony(银牌题/构造) 题意： 待补。 Solution： 瞎猜的。待补。 #include &lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } int n,m; signed main() { read(n); for(int i=1;i&lt;=n;i++) { m=max(m,(n*(i)*(n-i+1))); } printf(&quot;%.9f&quot;,1.0/m); } ","link":"https://gujinli.github.io/post/icpc2021-shang-hai-bu-fen-ti-jie/"},{"title":"搜索与图论","content":"DFS与BFS 注意剪枝，边界表示。 状态需要判重时，能不用map尽量不用，能用数字尽量不用字符串 树与图的遍历 正常遍历 拓扑排序：根据入度删点，入度为0的点加入队列bfs 最短路 floyd &amp; spfa &amp; dijkstra spfa：队头出队，松弛它的边，松弛了且不在队内的点入队。 判断负环： 判入队次数是否&gt;n 差分约束：按照dis[v]&lt;=dis[u]+wdis[v] &lt;= dis[u] + wdis[v]&lt;=dis[u]+w的形式建边即可 dij：每次取出当前距离最小的点，表示该点的最短路已经确定。 反向建边 虚点建边 最小生成树 prim kruskal 次小生成树？ prim维护f[i][j] 表示最小生成树中 i到j 的最长边 kruscal + lca O(1)离线查询 i到j 的最长边 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define ll long long #define space putchar(' ') #define endl putchar('\\n') #define debug puts(&quot;------------------------&quot;) #define lowbit(x) (x&amp;-x) #define LOCAL using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } inline int Rem() {int a=0,c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();return a*=b; } inline void write(int x) {if(x&gt;9)write(x/10);putchar('0'+x%10);} inline void W(int x) {if(x&lt;0){putchar('-'),x=-x;}write(x);} /**/ const int inf = 0x3f3f3f3f; const int N = 105; int t,n,m,e[N][N],cnt,dis[N],s1,s2,pre[N],f[N][N]; bool tree[N][N], vis[N]; struct edge { int from,to,w; }ed[N*N]; /**/ int main() { #if ONLINE_JUDGE #else freopen(&quot;test.in&quot;,&quot;r&quot;,stdin); freopen(&quot;test.out&quot;,&quot;w&quot;,stdout); #endif read(t); while(t--) { cnt = 0; read(n);read(m); for(int i=1;i&lt;=n;i++) { pre[i] = 0; for(int j=1;j&lt;=i+1;j++) e[i][j] = e[j][i] = inf, tree[i][j] = tree[j][i] = 0, f[i][j] = f[j][i] = 0; } for(int i=1,a,b,c;i&lt;=m;i++) { read(a);read(b);read(c); ed[++cnt] = (edge){a,b,c}; e[a][b] = e[b][a] = c; } for(int i=0;i&lt;=n;i++) dis[i] = inf, vis[i] = 0; dis[1] = 0; s1 = 0; for(int i=1;i&lt;=n;i++) { int u = 0; for(int j=1;j&lt;=n;j++) if(!vis[j]&amp;&amp;dis[j]&lt;dis[u]) u = j; vis[u] = 1; tree[pre[u]][u] = tree[u][pre[u]] = 1; if(u) s1 += dis[u]; for(int j=1;j&lt;=n;j++) { if(u==j) continue; if(vis[j]) { f[j][u] = f[u][j] = max(f[pre[u]][j], dis[u]); } if(!vis[j] &amp;&amp; dis[j] &gt; e[u][j]) { dis[j] = e[u][j]; pre[j] = u; } } } s2 = inf; for(int i=1;i&lt;=cnt;i++) { int u = ed[i].from, v = ed[i].to; if(tree[u][v]) continue; // printf(&quot;%d - %d = %d\\n&quot;,u,v,f[u][v]); s2 = min(s2, s1 - f[u][v] + ed[i].w); } cout &lt;&lt; s1 &lt;&lt;' '&lt;&lt; s2 &lt;&lt;'\\n'; } return 0; } 有向图有根最小生成树？ -&gt; 朱刘算法 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define ll long long #define space putchar(' ') #define endl putchar('\\n') #define debug puts(&quot;------------------------&quot;) #define lowbit(x) (x&amp;-x) #define LOCAL using namespace std; inline void read(int &amp;a) {a=0;int c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();a*=b; } inline int Rem() {int a=0,c=getchar(),b=1; while(c&gt;'9'||c&lt;'0') {if(c=='-')b=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-48,c=getchar();return a*=b; } inline void write(int x) {if(x&gt;9)write(x/10);putchar('0'+x%10);} inline void W(int x) {if(x&lt;0){putchar('-'),x=-x;}write(x);} /**/ const int N = 105, M = 1e4 + 5; int n, cnt, m, fa[N], id[N], vis[N]; double x[N], y[N], in[N]; struct edge { int from, to; double w; }e[M]; /**/ inline double get(int i, int j) { return sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])); } inline double zhuliu() { double ans = 0; int root = 1; while(1) { for(int i = 1; i &lt;= n; i++) in[i] = 0x3f3f3f3f; for(int i = 1; i &lt;= cnt; i++) { int u = e[i].from, v = e[i].to; if(u != v &amp;&amp; e[i].w &lt; in[v]) { fa[v] = u; in[v] = e[i].w; } } for(int i = 1; i &lt;= n; i++) if(in[i] == 0x3f3f3f3f) return -1; int tot = 0; in[root] = 0; for(int i = 1; i &lt;= n; i++) vis[i] = id[i] = 0; for(int i = 1; i &lt;= n; i++) { int u = i; ans += in[u]; while(vis[u] != i &amp;&amp; !id[u] &amp;&amp; u != root) vis[u] = i, u = fa[u]; if(u != root &amp;&amp; !id[u]) { id[u] = ++tot; for(int x = fa[u]; x != u; x = fa[x]) id[x] = tot; } } if(!tot) break; for(int i = 1; i &lt;= n; i++) if(!id[i]) id[i] = ++tot; int cnt_ = 0; for(int i = 1; i &lt;= cnt; i++) { int u = e[i].from, v = e[i].to; if(id[u] =! id[v]) e[++cnt_] = (edge){id[u], id[v], e[i].w - in[v]}; } cnt = cnt_; n = tot; root = id[root]; } return ans; } int main() { #if ONLINE_JUDGE #else freopen(&quot;test.in&quot;,&quot;r&quot;,stdin); freopen(&quot;test.out&quot;,&quot;w&quot;,stdout); #endif while(cin &gt;&gt; n &gt;&gt; m) { cnt = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; x[i] &gt;&gt; y[i]; } for(int i = 1, a, b; i &lt;= m; i++) { read(a); read(b); e[++cnt] = (edge){a, b, get(a, b)}; } double ans = zhuliu(); if(ans == -1) puts(&quot;poor snoopy&quot;); else printf(&quot;%.2f\\n&quot;, ans); } return 0; } 二分图： 待补习 ","link":"https://gujinli.github.io/post/sou-suo-yu-tu-lun/"},{"title":"动态规划基础","content":"线性dp： LIS： 严格上升：*lower_bound(f+1,f+1+n,a[i]) = a[i]; 非严格上升：*upper_bound(f+1,f+1+n,a[i]) = a[i]; LCS: 最长公共子序列 背包dp: 01背包：每种物品只能取一件 完全背包：每种物品可以取无数件 多重背包：每种物品有固定件数。 可进行二进制拆分优化。 分组背包：对不同组做背包就可以了。 区间dp: 枚举区间长度 枚举区间起点 枚举区间断点 树形dp: f[i][j]f[i][j]f[i][j] 中的 i 用来表示结点， j 用来表示状态信息。 状压dp： 数位dp： 记忆化搜索 类似dp。先写出dp方程然后在搜索中利用记忆化数组记录最优解。（剪枝？） ","link":"https://gujinli.github.io/post/dong-tai-gui-hua-ji-chu/"},{"title":"基础数据结构","content":"链表 单链表 双链表 基本没有正式用到的知识。像模拟的数据结构。 以 0 为 头节点， 1为尾节点。模拟实现即可。 循环链表 栈 先进后出 典例：表达式求值(acw 3302) 队列 先进先出 单调栈 维护一个单调的栈。每次弹栈时记录需要的信息 模板 例题 单调队列 维护一个单调的队列，记录信息，队首超出范围（或不符合当前要求）则弹出。 例题 kmp 字符串匹配。求串s在t中出现的次数。 记录一个 pi[i]pi[i]pi[i] 表示以 iii 为节点的串，前缀后缀相等的最大长度。 将s和t拼接起来，如果 pi[i]==npi[i] == npi[i]==n （n为s串长度）则证明出现了一次，ans++； 并查集 fa[i] 表示i节点的父节点。 压缩路径，按秩合并，带权并查集等常用思想。代码简单，难在灵活应用 堆 待补习，暂时用优先队列代替。 hash表 进制哈希。 使用自然溢出是否有必要模质数？ 是否有必要加一个小质数防止被卡？ 无特殊需求（如前缀和等）时，其实可以加。（但没啥很大意义） trie 字典树用边表示字母 有相同前缀的单词公用前缀节点，那我们可以的得出每个节点最多有26个子节点（在单词只包含小写字母的情况下） 整棵树的根节点是空的。为什么呢？便于插入和查找，这将会在后面解释。 每个单词结束的时候用一个特殊字符表示，图中用的 xxx ，那么从根节点到任意一个 xxx 所经过的边的所有字母表示一个单词。 有关异或：用01串建trie树，边为0或1。 ","link":"https://gujinli.github.io/post/ji-chu-shu-ju-jie-gou/"},{"title":"算法基础","content":"基础算法整理❗️ 排序 冒泡排序 O(n2)O(n^2)O(n2) n次遍历每次从1到n判断相邻的数字是否左小右大否则swap 选择排序 O(n2)O(n^2)O(n2) n次遍历每次找出最小数添加到一个新数组 插入排序 O(n2)O(n^2)O(n2) n次遍历每次将当前数添加到一个新数组末尾，并从后向前依次swap直到遇到一个小于等于当前数的数字。 希尔排序 O(n2)O(n^2)O(n2) n次遍历，每次将第i个数字与前面的数字swap知道遇到一个小于等于当前数的数字。 归并排序 O(nlogn)O(nlogn)O(nlogn) 每次将数组分成两段，分别处理好两段后合并起来。（递归） 快速排序 O(nlogn)O(nlogn)O(nlogn) 以中间数为基准数。双指针分别从前从后跑，遇到aia_iai​大于等于中间数aja_jaj​小于等于中间数则swap。直至$ i&gt;j。则。则。则j左边的数全部小于中间数，左边的数全部小于中间数，左边的数全部小于中间数，i$右边的数全部大于中间数。之后递归处理。 计数排序 O(n)O(n)O(n) 简易桶排序。每个数字放进对应的桶中++。遍历输出。 桶排序 O(n)O(n)O(n) 可以限定桶个数的升级桶排序。 二分 二分查找 二分答案 日报：二分边界问题 关于二分的问题在这份日报中讲的十分清晰。 分为两种方法，一种为记录中间值，另一种不记录。 不记录的情况则需要根据 l=midl = midl=mid 还是 l=mid+1l = mid + 1l=mid+1 小心死循环的情况。 总之遇到二分题的时候，认真思考判断边界的处理即可。 （当然直接使用记录中间值的方法也是一种不错的选择） 如果二分答案的值是小数，采取二分多次的方法（如1k或1w）来达到精度要求即可. 01分数规划： 待补习。 高精 sb 大模拟罢了 前缀和差分 前缀和: 线性 / 二(多)维 / 树上 还有基于dp的高维前缀和等等 差分: 维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的数。注意修改操作一定要在查询操作之前。 即多次区间加减，离线查询。 树上差分 ： 分为点差分和边差分。待补习。 双指针（又称尺取法） 日报：尺取法小结 维护两个指针 l,rl,rl,r ,每次确定区间的左端点,让 rrr 不断向右移动,直到满足条件停下,维护一下答案,直到 r&gt;nr&gt;nr&gt;n 或者其它情况 位运算 日报：二进制与位运算 离散化 离散化本质上可以看成是一种 哈希，其保证数据在哈希以后仍然保持原来的全/偏序关系。 通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。 用来离散化的可以是大整数、浮点数、字符串等等。 sort(lsh+1,lsh+1+n); cnt = unique(lsh+1,lsh+1+cnt) - lsh - 1; ID(x) = lower_bound(lsh+1,lsh+1+cnt,x) - lsh; 区间合并 (acwing 803) 给定n段区间，合并所有有交集的区间。 按左端点排序，贪心从左向右依次合并。 ","link":"https://gujinli.github.io/post/suan-fa-ji-chu/"}]}